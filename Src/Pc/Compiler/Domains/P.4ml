domain	P extends PStaticTyping, PStructuralTyping
{

}

domain PData
{        
    /*************************************************************/
    /****************          Type Language          ************/
    /*************************************************************/    
    Qualifier       ::= { NONE, REF, XFER}.
    
	TypeDef         ::= new (name: String, type: any TypeExpr + { NIL }).

    //// The BaseType REAL is the type of real machines.
	NameType        ::= new (name: String).
    BaseType        ::= new ({ NULL, BOOL, INT, EVENT, REAL, ANY }).
    TupType         ::= new (hd: any TypeExpr, tl: any TupType + { NIL }).
    NmdTupType      ::= new (hd: any NmdTupTypeField, tl: any NmdTupType + { NIL }).
    SeqType         ::= new (x: any TypeExpr).
    MapType         ::= new (k: any TypeExpr, v: any TypeExpr).
    NmdTupTypeField ::= new (qual: Qualifier, name: any String, type: any TypeExpr). 
	InterfaceType	::= new (ev: NonNullEventLabel, tail: any InterfaceType + {NIL}).
    TypeExpr        ::= NameType + BaseType + TupType + NmdTupType + SeqType + MapType + InterfaceType.
        
    /*************************************************************/
    /****************          Action Language        ************/
    /*************************************************************/    
                               
    //// Expressions
    Name       ::= new (name: String).
    New        ::= new (name: String, arg: any Expr + { NIL }).
    FunApp     ::= new (name: String, mod: String + { NIL }, args: any Exprs + { NIL }).
    NulApp     ::= new (op: Integer + Boolean + { THIS, NONDET, FAIRNONDET, NULL, HALT }).
    UnApp      ::= new (op: { NOT, NEG, KEYS, VALUES, SIZEOF }, arg1: any Expr).
    BinApp     ::= new (op: { ADD, SUB, MUL, INTDIV, AND, OR, EQ, NEQ, LT, LE, GT, GE, IDX, IN }, arg1: any Expr, arg2: any Expr).
    Field      ::= new (arg: any Expr, name: String + Natural).
    Default    ::= new (type: any TypeExpr). 
    Cast       ::= new (arg: any Expr, type: any TypeExpr). 
    Tuple      ::= new (body: any Exprs).
    NamedTuple ::= new (body: any NamedExprs).
    Exprs      ::= new (qual: Qualifier, head: any Expr, tail: any Exprs + { NIL }).              
    NamedExprs ::= new (field: String, exp: any Expr, tail: any NamedExprs + { NIL }).
    Expr       ::= Name + New + FunApp + NulApp + UnApp + BinApp + Field + Default + Cast + Tuple + NamedTuple.
    ExprsExt   ::= Expr + Exprs + NamedExprs.

    //// Statements
    NewStmt  ::= new (name: String, arg: any Expr + { NIL }, info: any SourceInfo).
    Raise    ::= new (ev: any Expr, arg: any Expr + { NIL }, info: any SourceInfo).
    Send     ::= new (dest: any Expr, ev: any Expr, arg: any Expr + { NIL }, qual: Qualifier, info: any SourceInfo).
    Announce  ::= new (ev: any Expr, arg: any Expr + { NIL }, info: any SourceInfo).
    FunStmt  ::= new (name: String, mod: String + { NIL }, args: any Exprs + { NIL }, aout: any Name + { NIL }, label: Natural, info: any SourceInfo).
    NulStmt  ::= new (op: { SKIP, POP }, info: any SourceInfo).
    BinStmt  ::= new (op: { REMOVE, ASSIGN, INSERT }, arg1: any Expr, arg2: any Expr, info: any SourceInfo).
    Return   ::= new (expr: any Expr + { NIL }, info: any SourceInfo).
    While    ::= new (cond: any Expr, body: any Stmt, info: any SourceInfo).
    Ite      ::= new (cond: any Expr, true: any Stmt, false: any Stmt, info: any SourceInfo).
    Seq      ::= new (s1: any Stmt, s2: any Stmt).
	Cases	 ::= new (trig: String + { NULL, HALT }, action: any AnonFunDecl, cases: any Cases + { NIL }).
	Receive  ::= new (cases: any Cases, label: Natural, info: any SourceInfo).
	Assert   ::= new (arg: any Expr, msg: String + { NIL }, info: any SourceInfo). 
	Print    ::= new (msg: String, info: any SourceInfo).
	
    Stmt ::= NewStmt + Raise + Send + Announce + FunStmt + NulStmt + BinStmt + Return + While + Ite + Seq + Receive + Assert + Print. 

	SourceInfo ::= new (line: Natural, col: Natural).
	FileInfo   ::= new (decl: FunDecl + AnonFunDecl, file: String + { NIL }).
	LineInfo   ::= new (decl: FunDecl + AnonFunDecl, loc: { ENTRY, EXIT }, line: Natural).

	/**************************************************************/
	/******* Module System Declarations **************************/
	/*************************************************************/
	
	EventSetDecl ::= new (name : String, ev: NonNullEventLabel).
	InterfaceTypeDecl ::= new (name: String, evsetName: String, argType: any TypeExpr).
	
	//// Machine Signature
	MachineExportsDecl ::= new (mach: any MachineDecl, iname: String).
	MachineReceivesDecl ::= new (mach: any MachineDecl, ev: NonNullEventLabel).
	MachineSendsDecl ::= new (mach: any MachineDecl, ev: NonNullEventLabel).
	MachineCreatesDecl ::= (mach: MachineDecl, iname: String).
	MachineSendsEventAll ::= new (mach: any MachineDecl).
	
	ModulePrivateEvent ::= new (mod: ModuleDecl, ev: String).
	ModulePrivateEventAll ::= new (mod: ModuleDecl).

	//// Module Declarations
	ModuleDecl ::= new (name: String).
	ModuleName ::= new (name: String).

	ModuleDef ::= new (name: String, mod: any ModuleExpr).
	HideExpr ::= new (evtNames: StringList, mod: any ModuleExpr). 
	RenameExpr ::= new (mNames: StringList, mNames': StringList, mod: any ModuleExpr).
	ExportExpr ::= new (mName: String, iName: String, mod: any ModuleExpr).
	AssumeExpr ::= new (monNames: StringList, mod: any ModuleExpr).
	AssertExpr ::= new (monNames: StringList, mod: any ModuleExpr).
	SafeExpr ::= new (mod: any ModuleExpr).
	ComposeExpr ::= new (left: any ModuleExpr, right: any ModuleExpr).
	ModuleExpr ::= ModuleName + HideExpr + RenameExpr + ExportExpr + AssumeExpr + AssertExpr + SafeExpr + ComposeExpr + ModuleDecl.

	//// Test Declarations and Implementation
	TestDecl ::= new (name: String, mod: ModuleExpr).
	RefinementDecl ::= new (name: String, lhs: ModuleExpr, rhs: ModuleExpr).
	ImplementationDecl ::= new (mod: ModuleExpr).

	////Module Signature 
	ModulePrivate ::= (mod: ModuleExpr, ev: NonNullEventLabel).
	ModuleSends ::= (mod: ModuleExpr, ev: NonNullEventLabel).
	ModuleReceives ::= (mod: ModuleExpr, ev: NonNullEventLabel).
	ModuleExports ::= (mod: ModuleExpr, i: String).  
	ModuleCreates ::= (mod: ModuleExpr, i: String).

	////Module Code Gen and Compatibity Helpers
	ModuleLinkMap ::= (mod: ModuleExpr, newMachineName: String, interfaceOrMachine: String, newImpMachine: MachineDecl).
	ModuleRenameMap ::= (mod: ModuleExpr, newName: String, impMachine: MachineDecl).  // for both machines and monitors
	ModuleSafeMap ::= (mod: ModuleExpr, newName: String, isSafe: Boolean).
	ModuleMonitorMap ::= (mod: ModuleExpr, newMonitorName: String, impMachine: MachineDecl).

	////Helper structs
	StringList ::= new (str: String, tl: any StringList + { NIL }).
	//create all sub strings
	MemberOfStringsList ::= sub (StringList, String).

    /*************************************************************/
    /****************  State Machine Declarations    *************/
    /*************************************************************/

    EventDecl      ::= fun (name: String -> card: any QueueConstraint, type: any TypeExpr + { NIL }).    
    MachineDecl    ::= fun (name: String, mod: ModuleDecl + { NIL } -> kind: { REAL, MODEL, MONITOR }, card: any QueueConstraint, start: any QualifiedName, isMain: Boolean).

	ObservesDecl   ::= new (monitor: MachineDecl, ev: NonNullEventLabel).

    VarDecl        ::= fun (name: String, owner: MachineDecl -> type: any TypeExpr).
    
	// For both FunDecl and AnonFunDecl, the order of locals in the input file is left to right 
	// and top to bottom (since multiple variable declaration lists are allowed).
	// For FunDecl, the order of params is left to right.
	// For AnonFunDecl, the order of envVars is left to right and top to bottom.
	// Thus, the numbering of variables is consistent across nested scopes.
    FunDecl        ::= fun (name: String, owner: MachineDecl + ModuleDecl -> kind: { REAL, PURE, MODEL }, params: any NmdTupType + { NIL }, return: any TypeExpr + { NIL }, locals: any NmdTupType + { NIL }, body: any Stmt, isPublic: Boolean).
    AnonFunDecl    ::= new (owner: MachineDecl + ModuleDecl, locals: any NmdTupType + { NIL }, body: any Stmt, envVars: any NmdTupType).
    
    StateDecl      ::= fun (name: any QualifiedName, owner: MachineDecl -> entryAction: any AnonFunDecl + String, exitFun: any AnonFunDecl + String, temperature: { HOT, WARM, COLD }).
    TransDecl      ::= fun (src: StateDecl, trig: String + { NULL, HALT } -> dst: any QualifiedName, action: any { PUSH } + AnonFunDecl + String).
    DoDecl         ::= fun (src: StateDecl, trig: String + { NULL, HALT } -> action: any { DEFER, IGNORE } + AnonFunDecl + String).

    PDecl          ::= EventDecl + MachineDecl + VarDecl + AnonFunDecl + FunDecl + StateDecl + TransDecl + DoDecl + ObservesDecl 
						+ InterfaceTypeDecl + MachineReceivesDecl + MachineSendsDecl + MachineExportsDecl + EventSetDecl + ImplementationDecl.            

    AssumeMaxInstances ::= new (bound: Natural).
    AssertMaxInstances ::= new (bound: Natural).
    QualifiedName      ::= new (name: String, qualifier: any QualifiedName + { NIL }).
    QueueConstraint    ::= AssumeMaxInstances + AssertMaxInstances + { NIL }.
    EventLabel         ::= String + { NULL, HALT }.
	NonNullEventLabel  ::= String + { HALT }.

    /*************************************************************/
    /****************          Annotations           *************/
    /*************************************************************/

    Annotation  ::= new (ant: Annotatable, key: String, value: any AnnotValue).
    Annotatable ::= EventDecl + MachineDecl + VarDecl + FunDecl + StateDecl + TransDecl + DoDecl + { NIL }.
    AnnotValue  ::= Integer + String + Boolean + { NULL }.


	// The function available for a machine is its local functions and the private static functions implemented by the module.
	// and also the public static functions implemented by other modules
	FunAvailable ::= (f: FunDecl, m: MachineDecl).
    FunAvailable(f, m) :- f is FunDecl( _, m, _, _, _, _, _, _), m is MachineDecl;
						  f is FunDecl( _, mod, _, _, _, _, _, TRUE), mod is ModuleDecl, m is MachineDecl;
						  f is FunDecl( _, mod, _, _, _, _, _, FALSE), mod is ModuleDecl, m is MachineDecl, m.mod = mod.

	
}

domain PStructuralTyping extends PData
{
    /*************************************************************/
	conforms no OneDeclError(_).
	conforms no TwoDeclError(_, _).
	conforms no DeclFunError(_, _).
    /*************************************************************/

	////// Three kinds of declaration errors (and missingDecl).
    OneDeclError ::= (PDecl).
    TwoDeclError ::= (PDecl, PDecl).
    DeclFunError ::= (PDecl, String).
	ModuleSystemDeclError ::= (s: String).

	[ rule_Classes = '"error, msg: Multiple transitions over the same event"']
	TwoDeclError(t1, t2) :- t1 != t2, t1 is TransDecl, t2 is TransDecl, t1.src = t2.src, t1.trig = t2.trig.
	[ rule_Classes = '"error, msg: Multiple actions over the same event"']
	TwoDeclError(a1, a2) :- a1 != a2, a1 is DoDecl(state, owner, _), a2 is DoDecl(state, owner, _), a1.src = a2.src, a1.trig = a2.trig.
			
	//// there should be a start state in each state machine.
	[ rule_Classes = '"error, msg: no start state in machine"']
	OneDeclError(m) :- m is MachineDecl, no StateDecl(s, m , _, _, _), m.start = s.
	
	//Valid TransDecl
	[ rule_Classes = '"error, msg: transition on an undefined event"']
	OneDeclError(trns) :- trns is TransDecl, no EventDecl(trns.trig, _, _), trns.trig != NULL, trns.trig != HALT.
	[rule_Classes = '"error, msg: transition to an undefined state"']
	OneDeclError(trns) :- trns is TransDecl, no StateDecl(trns.dst, trns.src.owner, _, _, _).
	
	[rule_Classes = '"error, msg: transition function not defined"']
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String, 
	                      no FunDecl(act, trns.src.owner, _, _, _, _, _, _).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is TransDecl(_, _, _, act), act : String, FunDecl(act, trns.src.owner, _, p, _, _, _, _), p != NIL;
	                      trns is TransDecl(_, _, _, act), act : String, FunDecl(act, trns.src.owner.mod, _, p, _, _, _, FALSE), p != NIL.
	
	//Valid DoDecl
	[ rule_Classes = '"error, msg: action on an undefined event"']
	OneDeclError(doD) :- doD is DoDecl, no EventDecl(doD.trig, _, _), doD.trig != HALT, doD.trig != NULL.
	
	[rule_Classes = '"error, msg: function not defined"']
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String, 
	                      no FunDecl(act, trns.src.owner, _, _, _, _, _, _), no FunDecl(act, trns.src.owner.mod, _, _, _, _, _, FALSE).
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	OneDeclError(trns) :- trns is DoDecl(_, _, act), act : String , FunDecl(act, trns.src.owner, _, p, _, _, _, _), p != NIL;
	                      trns is DoDecl(_, _, act), act : String , FunDecl(act, trns.src.owner.mod, _, p, _, _, _, FALSE), p != NIL.
	
	//Entry Exit Functions
	[rule_Classes = '"error, msg: undefined function for entry"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String, no FunDecl(eF, s.owner, _, _, _, _, _, _). 

	[rule_Classes = '"error, msg: undefined function for exit"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String, no FunDecl(eF, s.owner, _, _, _, _, _, _). 

	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, eF, _, _), eF : String , FunDecl(eF, s.owner, _, p, _, _, _, _), p != NIL;
	                       s is StateDecl(_, _, eF, _, _), eF : String , FunDecl(eF, s.owner.mod, _, p, _, _, _, FALSE), p != NIL.
	
	[rule_Classes = '"error, msg: function cannot take arguments"']
	DeclFunError(s, eF) :- s is StateDecl(_, _, _, eF, _), eF : String , FunDecl(eF, s.owner, _, p, _, _, _, _), p != NIL;
	                       s is StateDecl(_, _, _, eF, _), eF : String , FunDecl(eF, s.owner.mod, _, p, _, _, _, FALSE), p != NIL.
	
	//cannot have null in Monitors
	[rule_Classes = '"error, msg: null transitions not allowed in monitors"']
	OneDeclError(t) :- t is TransDecl(s, NULL, _, _), s.owner.kind = MONITOR.
	[rule_Classes = '"error, msg: push transitions not allowed in monitors"']
	OneDeclError(t) :- t is TransDecl(s, _, _, PUSH), s.owner.kind = MONITOR.

	//no defer in monitors
	[rule_Classes = '"error, msg: defer not allowed in monitor"']
	OneDeclError(d) :- d is DoDecl(s, _, DEFER), s.owner.kind = MONITOR.	

	//event in observes is defined
	[rule_Classes = '"error, msg: event in observes set is not declared"']
	OneDeclError(obs) :- obs is ObservesDecl, obs.monitor.kind = MONITOR, no EventDecl(obs.ev, _, _).	

	//event in eventset not declared
	[rule_Classes = '"error, msg: unknown event in event-set declaration"']
	OneDeclError(eventset) :- eventset is EventSetDecl(_, ev), ev != HALT, no EventDecl(ev, _, _).

	//eventset in interface type
	[rule_Classes = '"error, msg: unknown eventset in interface declaration"']
	OneDeclError(inter) :- inter is InterfaceTypeDecl(_, es, _), no EventSetDecl(es, _).

	//event in receives of a machine
	[rule_Classes = '"error, msg: event in receives is not declared"']
	OneDeclError(receivesE) :- receivesE is MachineReceivesDecl(_, ev), no EventDecl(ev, _, _), ev!= HALT.

	//event in sends of a machine
	[rule_Classes = '"error, msg: event in sends is not declared"']
	OneDeclError(s) :- s is MachineSendsDecl(_, ev), no EventDecl(ev, _, _), ev!= HALT.
	
	//only one implementation list declaration
	[rule_Classes = '"error, msg: atmost one implementation module list is allowed"']
	OneDeclError(ml1) :- ml1 is ImplementationDecl, ml2 is ImplementationDecl, ml1 != ml2.	
	
	//interface declared in the exports is legal
	[rule_Classes = '"error, msg: interface in exports is not declared"']
	OneDeclError(ex) :- ex is MachineExportsDecl(_, i), no InterfaceTypeDecl(i, _, _).						
}

domain PStaticTyping extends PData
/*
[
    compiler_ProductivityCheck = "TypeOf[1]"
]
*/
{
    /*************************************************************/
	conforms no TypeOf(_, _, ERROR).
	conforms no ConstructorTypeError(_).
	conforms no DupNmdSubE(_, _, _, _).
	conforms no PurityError(_, _).
	conforms no MonitorError(_, _).
	conforms no LValueError(_, _).
	conforms no BadLabelError(_).
	conforms no PayloadError(_).
	conforms no TypeDefError(_).
	conforms no ModuleDefError(_).
	conforms no ModuleConstructionIllegal(_).
	conforms no ModuleCompositionIllegal(_, _).
	conforms no WellFormednessError(_, _).
	conforms no FunDeclQualifierError(_, _).
	conforms no FunCallQualifierError(_, _, _).
	conforms no SendQualifierError(_, _).
	conforms no UnavailableVarAccessError(_, _, _).
	conforms no UnavailableParameterError(_, _).
	conforms no FunRetError(_).
	conforms no IllegalMainMachine(_).
    /*************************************************************/

	//// Check that TypeDef's are used properly

	AllTypeExprs ::= sub (TypeExpr).
	TypeDefError ::= (name: String).

	[rule_Classes = '"error, msg: undefined type"']
	TypeDefError(name) :- AllTypeExprs(type), type = NameType(name), no TypeDef(name, _), no InterfaceTypeDecl(name, _, _).

	[rule_Classes = '"error, msg: multiple type definitions for a type name"']
	TypeDefError(name) :- TypeDef(name, type1), TypeDef(name, type2), type1 != type2.

	TypeDefDepends ::= sub (typeDef: TypeDef, type: NameType).
	NameTypeDepends ::= (name1: String, name2: String).
	NameTypeDepends(typeDef.name, type.name) :- TypeDefDepends(typeDef, type).
	NameTypeDepends(name1, name3) :- NameTypeDepends(name1, name2), NameTypeDepends(name2, name3).
	[rule_Classes = '"error, msg: type depends on itself"']
	TypeDefError(name) :- NameTypeDepends(name, name).

	TypeExpansion ::= (type: TypeExpr, eType: TypeExpr).

	TypeExpansion(BaseType(NULL), BaseType(NULL)).
	TypeExpansion(BaseType(BOOL), BaseType(BOOL)).
	TypeExpansion(BaseType(INT), BaseType(INT)).
	TypeExpansion(BaseType(EVENT), BaseType(EVENT)).
	TypeExpansion(BaseType(REAL), BaseType(REAL)).
	TypeExpansion(BaseType(ANY), BaseType(ANY)).

	TypeExpansion(t, t) :- TypeOf(_, Tuple(_), t), t : TypeExpr.
	TypeExpansion(t, t) :- TypeOf(_, NamedTuple(_), t), t : TypeExpr.
	TypeExpansion(t, t) :- TypeExpansion(_, TupType(t, _)), t : TypeExpr.
	TypeExpansion(t, t) :- TypeExpansion(_, TupType(_, t)), t : TypeExpr.
	TypeExpansion(t, t) :- TypeExpansion(_, NmdTupType(f, _)), t = f.type.
	TypeExpansion(t, t) :- TypeExpansion(_, NmdTupType(_, t)), t : TypeExpr.

	TypeExpansion(type, type)  :- AllTypeExprs(type), type : InterfaceType.
	TypeExpansion(type, type)  :- TypeDef(typeName, NIL), no TypeDefError(typeName), type = NameType(typeName).
	TypeExpansion(type, eType) :- TypeDef(typeName, typeExpr), typeExpr: TypeExpr, no TypeDefError(typeName), type = NameType(typeName), TypeExpansion(typeExpr, eType).
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = NameType(name), InterfaceTypeDecl(name, _, _), InterfaceTypeDeclList(name, eType).	
	TypeExpansion(type, eType) :- MachineExportsDecl(m, name), type = NameType(name), InterfaceTypeDecl(name, _, _), InterfaceTypeDeclList(name, eType).
	TypeExpansion(type, eType) :- MachineCreatesDecl(m, name), type = NameType(name), InterfaceTypeDecl(name, _, _), InterfaceTypeDeclList(name, eType).	
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = TupType(hd, NIL), TypeExpansion(hd, hd'), eType = TupType(hd', NIL).
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = TupType(hd, tl), tl != NIL, TypeExpansion(hd, hd'), TypeExpansion(tl, tl'), eType = TupType(hd', tl').
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = NmdTupType(NmdTupTypeField(qual, name, hd), NIL), TypeExpansion(hd, hd'), eType = NmdTupType(NmdTupTypeField(qual, name, hd'), NIL).
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = NmdTupType(NmdTupTypeField(qual, name, hd), tl), tl != NIL, TypeExpansion(hd, hd'), TypeExpansion(tl, tl'), eType = NmdTupType(NmdTupTypeField(qual, name, hd'), tl').
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = SeqType(x), TypeExpansion(x, x'), eType = SeqType(x').
	TypeExpansion(type, eType) :- AllTypeExprs(type), type = MapType(k, v), TypeExpansion(k, k'), TypeExpansion(v, v'), eType = MapType(k', v').

    //// The declarations that may contain expressions or statements that should be typed.
    TypingContext ::= FunDecl + AnonFunDecl.
    
    //// The set of typeable expressions and statements.
    Typeable ::= Expr + Stmt + Exprs + NamedExprs + Cases.
    
    //// The type judgement. NIL is a placeholder for untyped constructs.
    TypeOf ::= (cntxt: TypingContext, expr: Typeable, type: TypeExpr + { ERROR, NIL }).

    //// All typing contexts anywhere in the input program.
	SubCntxt ::= sub (cntxt: TypingContext).
    
	SubSE ::= (cntxt: TypingContext, typeable: Typeable).
	SubSE(cntxt, typeable) :- SubCntxt(cntxt), cntxt = AnonFunDecl(_, _, typeable, _).
	SubSE(cntxt, typeable) :- SubCntxt(cntxt), cntxt = FunDecl(_, _, _, _, _, _, typeable, _).
	SubSE(c, e), SubSE(c, s) :- SubSE(c, While(e, s, _)).
	SubSE(c, e), SubSE(c, s1), SubSE(c, s2) :- SubSE(c, Ite(e, s1, s2, _)).
	SubSE(c, s1), SubSE(c, s2) :- SubSE(c, Seq(s1, s2)).
	SubSE(c, cases) :- SubSE(c, Receive(cases, _, _)).
	SubSE(c, cases) :- SubSE(c, Cases(_, _, cases)), cases: Cases.
	SubSE(c, e) :- SubSE(c, Return(e, _)), e: Expr.
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, BinStmt(_, e1, e2, _)).
	SubSE(c, e) :- SubSE(c, Assert(e, _, _)).
	SubSE(c, es) :- SubSE(c, FunStmt(_, _, es, _, _, _)), es: Exprs.
	SubSE(c, e) :- SubSE(c, FunStmt(_, _, es, e, _, _)), e: Name.
	SubSE(c, e) :- SubSE(c, Announce(e, _, _)).
	SubSE(c, e) :- SubSE(c, Announce(_, e, _)), e: Expr.
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, Send(e1, e2, _, _, _)).
	SubSE(c, e) :- SubSE(c, Send(_, _, e, _, _)), e: Expr.
	SubSE(c, e) :- SubSE(c, Raise(e, _, _)).
	SubSE(c, e) :- SubSE(c, Raise(_, e, _)), e: Expr.
	SubSE(c, e) :- SubSE(c, NewStmt(_, e, _)), e: Expr.
	SubSE(c, e) :- SubSE(c, New(_, e)), e: Expr.
	SubSE(c, es) :- SubSE(c, FunApp(_, _, es)), es: Exprs.
	SubSE(c, e) :- SubSE(c, UnApp(_, e)).
	SubSE(c, e1), SubSE(c, e2) :- SubSE(c, BinApp(_, e1, e2)).
	SubSE(c, e) :- SubSE(c, Field(e, _)).
	SubSE(c, e) :- SubSE(c, Cast(e, _)).
	SubSE(c, es) :- SubSE(c, Tuple(es)).
	SubSE(c, es) :- SubSE(c, NamedTuple(es)).
	SubSE(c, e) :- SubSE(c, Exprs(_, e, _)).
	SubSE(c, es) :- SubSE(c, Exprs(_, _, es)), es: Exprs.
    SubSE(c, e) :- SubSE(c, NamedExprs(_, e, _)).
	SubSE(c, es) :- SubSE(c, NamedExprs(_, _, es)), es: NamedExprs.


	/*************************************************/
	/*		Expanding the Module Expressions		*/
	/************************************************/
	AllModuleExprs ::= sub (ModuleExpr).
	ModuleDefError ::= (name: String).
	
	[rule_Classes = '"error, msg: undefined module"']
	ModuleDefError(name) :- AllModuleExprs(modEx), modEx = ModuleName(name), no ModuleDecl(name), no ModuleDef(name, _).

	[rule_Classes = '"error, msg: multiple named module definitions for the same name"']
	ModuleDefError(modName) :- ModuleDef(modName, expr1), ModuleDef(modName, expr2), expr1 != expr2.

	ModuleDefDepends ::= sub (modDef: ModuleDef, mName: ModuleName).
	ModuleNameDepends ::= (name1: String, name2: String).
	ModuleNameDepends(nmodule.name, modName.name) :- ModuleDefDepends(nmodule, modName).
	ModuleNameDepends(name1, name3) :- ModuleNameDepends(name1, name2), ModuleNameDepends(name2, name3).
	[rule_Classes = '"error, msg: named module depends on itself"']
	ModuleDefError(name) :- ModuleNameDepends(name, name).

	
	ModuleExprExpansion ::= (modExpr: ModuleExpr, eModExpr: ModuleExpr).
	
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleName(name), emodExpr = ModuleDecl(name), no ModuleDef(name, _).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleName(name), no ModuleDefError(name), no ModuleDecl(name), ModuleDef(name, modExpr'), ModuleExprExpansion(modExpr', emodExpr).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ModuleDecl(name), emodExpr = ModuleDecl(name).
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = HideExpr(s, modExpr'), emodExpr = HideExpr(s, emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = RenameExpr(s1, s2, modExpr'), emodExpr = RenameExpr(s1, s2, emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ExportExpr(s1, s2, modExpr'), emodExpr = ExportExpr(s1, s2, emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssumeExpr(s, modExpr'), emodExpr = AssumeExpr(s, emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = AssertExpr(s, modExpr'), emodExpr = AssertExpr(s, emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = SafeExpr(modExpr'), emodExpr = SafeExpr(emodExpr'),  ModuleExprExpansion(modExpr', emodExpr').
	ModuleExprExpansion(modExpr, emodExpr) :- AllModuleExprs(modExpr), modExpr = ComposeExpr(modExpr', modExpr''), emodExpr = ComposeExpr(emodExpr', emodExpr''), ModuleExprExpansion(modExpr', emodExpr'), ModuleExprExpansion(modExpr'', emodExpr'').


	//// All expanded Module Exprs
	AllExpandedModuleExprs ::= (modExpr: ModuleExpr).
	AllExpandedModuleExprs(emodExpr) :- AllModuleExprs(modExpr), ModuleExprExpansion(modExpr, emodExpr).

	//// All modules in module expr
	AllModuleDecls ::= (modExpr: ModuleExpr, mod: ModuleDecl).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, AllModuleDecls(modExpr.mod, mod).
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, mod = modExpr.
	AllModuleDecls(modExpr, mod) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.left, mod);
									AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, AllModuleDecls(modExpr.right, mod).

	/**************************************************************************/
	/*		Check that there is only one main machine in each moduleExpr	  */
	/**************************************************************************/
	IllegalMainMachine ::= (modExpr: ModuleExpr).
	[rule_Classes = '"error, msg: zero or more than one main machine in the module expression"']
	IllegalMainMachine(modExpr) :- TestDecl(_, modExpr), ModuleExprExpansion(modExpr, emodExpr), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), AllModuleDecls(emodExpr, mod)}) != 1;
								   ImplementationDecl(modExpr), ModuleExprExpansion(modExpr, emodExpr), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), AllModuleDecls(emodExpr, mod)}) != 1;
								   RefinementDecl(_, modExpr, _), ModuleExprExpansion(modExpr, emodExpr), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), AllModuleDecls(emodExpr, mod)}) != 1;
								   RefinementDecl(_, _, modExpr), ModuleExprExpansion(modExpr, emodExpr), count({mach | mach is MachineDecl(_, mod, _, _, _, TRUE), AllModuleDecls(emodExpr, mod)}) != 1.

	/************************************************************************************/
	/*	Generate sends, receives, exports, private and creates for Module Expressions   */
	/************************************************************************************/
	///List representation of interfacetypedecl
	InterfaceTypeDeclList ::= (name: String, it: InterfaceType).
	InterfaceTypeDeclList(name, it) :- InterfaceTypeDecl(name, esname, _), it = toList(#InterfaceType, NIL, {ev | EventSetDecl(esname, ev) }), it : InterfaceType.

	SendsForModuleExpr ::= (mExpr: ModuleExpr, ev: NonNullEventLabel).
	PrivateForModuleExpr ::= (mExpr: ModuleExpr, ev: NonNullEventLabel).
	CreatesForModuleExpr ::= (mExpr: ModuleExpr, i: String).
	ExportsForModuleExpr ::= (mExpr: ModuleExpr, i: String).
	ReceivesForModuleExpr ::= (mExpr: ModuleExpr, ev: NonNullEventLabel).

	//// private events 
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEvent(modExpr, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, ModulePrivateEventAll(modExpr), MachineReceivesDecl(mach, ev), mach.mod = modExpr.
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, PrivateForModuleExpr(modExpr.mod, ev).
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, PrivateForModuleExpr(modExpr.mod, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MemberOfStringsList(modExpr.evtNames, ev).
	PrivateForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, PrivateForModuleExpr(modExpr.left, ev);
										 AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, PrivateForModuleExpr(modExpr.right, ev).
									 

	//// sends list 
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineSendsDecl(mach, ev), mach.mod = modExpr, no ModulePrivateEvent(modExpr, ev). 
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, SendsForModuleExpr(modExpr.mod, ev).
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, SendsForModuleExpr(modExpr.left, ev);
									   AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, SendsForModuleExpr(modExpr.right, ev).
	SendsForModuleExpr(modExpr, ev) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, MachineSendsDecl(_, ev), SendsForModuleExpr(modExpr.mod, ev), no MemberOfStringsList(modExpr.evtNames, ev).
	


	//// exports list
	AllExportedInterfaces ::= (ix: String).
	AllExportedInterfaces(ix) :- ExportExpr(_, ix, _); MachineExportsDecl(_, ix).
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineExportsDecl(mach, ix), mach.mod = modExpr.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), ExportsForModuleExpr(modExpr.mod, ix),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl, toSymbol(modExpr) != #ExportExpr.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ExportsForModuleExpr(modExpr.mod, ix);
										 AllExpandedModuleExprs(modExpr), modExpr : ExportExpr, ix = modExpr.iName.
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ExportsForModuleExpr(modExpr.left, ix);
									     AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, ExportsForModuleExpr(modExpr.right, ix).									 
	ExportsForModuleExpr(modExpr, ix) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllExportedInterfaces(ix), ExportsForModuleExpr(modExpr.mod, ix), InterfaceTypeDecl(ix, es, _), count({ev | EventSetDecl(es, ev), MemberOfStringsList(modExpr.evtNames, ev)}) = 0.

	//// creates list
	AllCreatedInterfaces ::= (ic: String).
	AllCreatedInterfaces(ic) :- MachineCreatesDecl(_, ic).
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ModuleDecl, MachineCreatesDecl(mach, ic), mach.mod = modExpr.
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), CreatesForModuleExpr(modExpr.mod, ic),
										 toSymbol(modExpr) != #HideExpr, toSymbol(modExpr) != #ComposeExpr, toSymbol(modExpr) != #ModuleDecl.
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, CreatesForModuleExpr(modExpr.left, ic);
									     AllExpandedModuleExprs(modExpr), modExpr : ComposeExpr, CreatesForModuleExpr(modExpr.right, ic).									 
	CreatesForModuleExpr(modExpr, ic) :- AllExpandedModuleExprs(modExpr), modExpr : HideExpr, AllCreatedInterfaces(ic), CreatesForModuleExpr(modExpr.mod, ic), InterfaceTypeDecl(ic, es, _), count({ev | EventSetDecl(es, ev), MemberOfStringsList(modExpr.evtNames, ev)}) = 0.

	//// receives list
	ReceivesForModuleExpr(modExpr, er) :- AllExpandedModuleExprs(modExpr), ExportsForModuleExpr(modExpr, ix), InterfaceTypeDecl(ix, es, _), EventSetDecl(es, er).

	/**************************************************************************/
	/*	Compute the permission set associated with each high level type 	 */
	/*************************************************************************/
	//A(e)
	EmbeddedPermissionsInType ::= (t: TypeExpr, perm: NonNullEventLabel).

	EmbeddedPermissionsInType(BaseType(REAL), ev),
	EmbeddedPermissionsInType(BaseType(ANY), ev)   :- EventDecl(ev, _, _).

	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype : InterfaceType, InterfaceTypeDeclList(i, type), InterfaceTypeDecl(i, es, _), EventSetDecl(es, ev).	
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = TupType(hd, NIL), EmbeddedPermissionsInType(hd, ev).
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = TupType(hd, tl), tl != NIL, EmbeddedPermissionsInType(hd, ev);
											AllTypeExprs(type), TypeExpansion(type, etype), etype = TupType(hd, tl), tl != NIL, EmbeddedPermissionsInType(tl, ev).
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = NmdTupType(NmdTupTypeField(qual, name, hd), NIL), EmbeddedPermissionsInType(hd, ev).
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = NmdTupType(NmdTupTypeField(qual, name, hd), tl), tl != NIL, EmbeddedPermissionsInType(hd, ev);
	 										AllTypeExprs(type), TypeExpansion(type, etype), etype = NmdTupType(NmdTupTypeField(qual, name, hd), tl), tl != NIL, EmbeddedPermissionsInType(tl, ev).
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = SeqType(x), EmbeddedPermissionsInType(x, ev).
	EmbeddedPermissionsInType(type, ev)  :- AllTypeExprs(type), TypeExpansion(type, etype), etype = MapType(k, v), EmbeddedPermissionsInType(v, ev).

	/**************************************************************************/
	/**				Check that the module contruction is legal			  	  */
	/**************************************************************************/
	ModuleConstructionIllegal ::= (String).
	
	//// Export Operation 1 (m \in M)
	[rule_Classes = '"error, msg: exported machine undefined in the module expression"']
	ModuleConstructionIllegal(m) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), no ModuleRenameMap(mod, m, _).

	//// Export Operation 2 (\alpha not empty and is defined)
	[rule_Classes = '"error, msg: exported interface not declared"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, _), no InterfaceTypeDecl(ix, _, _).

	//// Export Operation 3 (\alpha = MR(m)\EP)
	[rule_Classes = '"error, msg: interface exported is not equal to the interface implemented by machine"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), ModuleRenameMap(mod, m, mach), impInterface = toList(#InterfaceType, NIL, {ev | MachineReceivesDecl(mach, ev), no PrivateForModuleExpr(mod, ev)}), InterfaceTypeDeclList(ix, exInterface), exInterface != impInterface.

	//// Export Operation 4 (constructor type match)
	[rule_Classes = '"error, msg: exported interface constructor type is not a sub-type of the contructor type of implemented machine"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), ModuleRenameMap(mod, m, mach), InterfaceTypeDecl(ix, _, iargt), ConstructorType(mach, _, ct), TypeRel(iargt, ct, k), ct != iargt, k != SUB.

	//// Export Operation 5 (\alpha is disjoint to all dom(IX))
	[rule_Classes = '"error, msg: interface being exported is not disjoint from the interfaces already exported by the module expression"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), ExportsForModuleExpr(mod, ix'), 
									InterfaceTypeDeclList(ix, eIx), InterfaceTypeDeclList(ix', eIx'), eIx = eIx';
									AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), ExportsForModuleExpr(mod, ix'), 
									InterfaceTypeDecl(ix, es, _), InterfaceTypeDecl(ix', es', _), EventSetDecl(es, ev), EventSetDecl(es', ev).

	/// Export Operation 6 (\alpha is disjoint or equal to all IC)
	[rule_Classes = '"error, msg: interface being exported is not disjoint or equal to the interfaces created by the module expression"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), CreatesForModuleExpr(mod, ic), 
									InterfaceTypeDeclList(ix, eIx), InterfaceTypeDeclList(ic, eIc), eIx != eIc, 
									InterfaceTypeDecl(ix, es, _), InterfaceTypeDecl(ic, es', _), EventSetDecl(es, ev), EventSetDecl(es', ev).
									
	/// Export Operation 7 (permissions in mod-expression is disjoint from \alpha )
	[rule_Classes = '"error, msg: after hidding the public events in receives or sends have private permission in them"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = ExportExpr(m, ix, mod), InterfaceTypeDecl(ix, es, _), EventSetDecl(es, ev), 
									 EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(modExpr, perm).


	////Rename Operation
	//check if the names in rename exists
	[rule_Classes = '"error, msg: machine name already exists in the module expression"']
	ModuleConstructionIllegal(mname) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldNames, newNames, mod), MemberOfStringsList(newNames, mname), ModuleRenameMap(mod, mname, _);
								  		AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldNames, newNames, mod), MemberOfStringsList(newNames, mname), mach.name = mname, ModuleRenameMap(mod, _, mach).
	[rule_Classes = '"error, msg: machine being renamed does not exists in the module expression"']
	ModuleConstructionIllegal(mname) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldNames, newNames, mod), MemberOfStringsList(oldNames, mname), no ModuleRenameMap(mod, mname, _).

	[rule_Classes = '"error, msg: length of the old and new machine names list is not equal"']
	ModuleConstructionIllegal(oldNames.str) :- AllExpandedModuleExprs(modExpr), modExpr = RenameExpr(oldNames, newNames, _), lstLength(#StringList, oldNames) != lstLength(#StringList, newNames).

	////Assume and Assert Operation
	//Monitor is defined
	[rule_Classes = '"error, msg: undefined monitor"']
	ModuleConstructionIllegal(mon) :- AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, _), MemberOfStringsList(monNames, mon), no MachineDecl(mon, NIL, MONITOR, _, _, _);
										AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, _), MemberOfStringsList(monNames, mon), no MachineDecl(mon, NIL, MONITOR, _, _, _).
	
	//Events observed by monitor must be in ES or EP
	[rule_Classes = '"error, msg: monitors observes list contains an event that is not sends or private events of the module expression"']
	ModuleConstructionIllegal(mon) :- AllExpandedModuleExprs(modExpr), modExpr = AssumeExpr(monNames, mod), MemberOfStringsList(monNames, mon), monDecl is MachineDecl(mon, NIL, MONITOR, _, _, _),
										ObservesDecl(monDecl, ev), no SendsForModuleExpr(mod, ev), no PrivateForModuleExpr(mod, ev);
									  AllExpandedModuleExprs(modExpr), modExpr = AssertExpr(monNames, mod), MemberOfStringsList(monNames, mon), monDecl is MachineDecl(mon, NIL, MONITOR, _, _, _),
									  ObservesDecl(monDecl, ev), no SendsForModuleExpr(mod, ev), no PrivateForModuleExpr(mod, ev).

	//Hide Operation
	//alpha is disjoint from EP
	[rule_Classes = '"error, msg: trying to hide private event of the module expression "']
	ModuleConstructionIllegal(ev) :- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), PrivateForModuleExpr(mod, ev), MemberOfStringsList(evtList, ev).

	//for each interface in dom(IX) and IC it is either disjoint from alpha or included in it.
	[rule_Classes = '"error, msg: trying to partially hide an exported interface of the module expression"']
	ModuleConstructionIllegal(ix) :- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), ExportsForModuleExpr(mod, ix), InterfaceTypeDecl(ix, es, _), EventSetDecl(es, ev1), 
									 MemberOfStringsList(evtList, ev1), EventSetDecl(es, ev2), no MemberOfStringsList(evtList, ev2).

	[rule_Classes = '"error, msg: trying to partially hide an interface created by the module expression"']
	ModuleConstructionIllegal(ic) :- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), CreatesForModuleExpr(mod, ic), InterfaceTypeDecl(ic, es, _), EventSetDecl(es, ev1), 
									 MemberOfStringsList(evtList, ev1), EventSetDecl(es, ev2), no MemberOfStringsList(evtList, ev2).

	/// (permissions in ER + ES is disjoint from EP )
	[rule_Classes = '"error, msg: after hidding the public events in receives or sends have private permission in them"']
	ModuleConstructionIllegal(evtList.str) :- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), SendsForModuleExpr(modExpr, ev), 
									 		  EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(modExpr, perm);
									 		  AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), ReceivesForModuleExpr(modExpr, ev), 
									 		  EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(modExpr, perm).

	//// trying to hide an interface in IC that is not in IX
	[rule_Classes = '"error, msg: illegal hiding of a created interface that is not exported by the module expression "']
	ModuleConstructionIllegal(evtList.str) :- AllExpandedModuleExprs(modExpr), modExpr = HideExpr(evtList, mod), CreatesForModuleExpr(mod, ic), InterfaceTypeDecl(ic, es, _), EventSetDecl(es, ev), 
											  MemberOfStringsList(evtList, ev), no ExportsForModuleExpr(mod, ix), InterfaceTypeDeclList(ic, x),  InterfaceTypeDeclList(ix, x).

	////Composition Compatibility checks
	ModuleCompositionIllegal ::= (modL: ModuleExpr, modR:ModuleExpr).

	///// All composition expressions
	AllCompositionExprs ::= (modL: ModuleExpr, modR: ModuleExpr, emodL: ModuleExpr, emodR: ModuleExpr).
	AllCompositionExprs(modL, modR, emodL, emodR) :- AllModuleExprs(modExpr), modExpr = ComposeExpr(modL, modR), ModuleExprExpansion(modL, emodL), ModuleExprExpansion(modR, emodR).
	//// Mp and Mq are disjoint
	[rule_Classes = '"error, msg: compatibility error> machine names are not disjoint"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), ModuleRenameMap(emodL, mname, _), ModuleRenameMap(emodR, mname, _).

	//// dom(IXp) and dom(IXq) are disjoint
	[rule_Classes = '"error, msg: compatibility error> exported interfaces are not disjoint"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), ExportsForModuleExpr(emodL, ixL), ExportsForModuleExpr(emodR, ixR), 
											InterfaceTypeDecl(ixL, esL, _), EventSetDecl(esL, ev), InterfaceTypeDecl(ixR, esR, _), EventSetDecl(esR, ev).

											

	//// ICp and ICq are disjoint
	[rule_Classes = '"error, msg: compatibility error> created interfaces are not disjoint"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), CreatesForModuleExpr(emodL, icL), CreatesForModuleExpr(emodR, icR), 
											InterfaceTypeDecl(icL, esL, _), EventSetDecl(esL, ev), InterfaceTypeDecl(icR, esR, _), EventSetDecl(esR, ev).

	//// ESp and ESq are disjoint
	[rule_Classes = '"error, msg: compatibility error> sends are not disjoint"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), SendsForModuleExpr(emodL, ev), SendsForModuleExpr(emodR, ev).

	//// ES and EP are disjoint
	[rule_Classes = '"error, msg: compatibility error> sends and privates are not disjoint"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), SendsForModuleExpr(emodL, ev), PrivateForModuleExpr(emodR, ev);	
											AllCompositionExprs(modL, modR, emodL, emodR), SendsForModuleExpr(emodR, ev), PrivateForModuleExpr(emodL, ev).

	//// e \in ER + ES, all a in A(e) is disjoint from EP
	[rule_Classes = '"error, msg: compatibility error> after composition the public events in receives or sends has private permissions in them"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), ReceivesForModuleExpr(composedMod, ev),
											EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(composedMod, perm);
											AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), SendsForModuleExpr(composedMod, ev),
											EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(composedMod, perm).

	//// IX of the composed module is disjoint from EP of the composed module
	[rule_Classes = '"error, msg: compatibility error> after composition the exported interfaces are not disjoint from the private events"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), ExportsForModuleExpr(composedMod, ix),
											InterfaceTypeDecl(ix, es, _), EventSetDecl(es, ev), PrivateForModuleExpr(composedMod, ev).

	//// IC of the composed module is disjoint from EP of the composed module
	[rule_Classes = '"error, msg: compatibility error> after composition the created interfaces are not disjoint from the private events"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), CreatesForModuleExpr(composedMod, ic),
											InterfaceTypeDecl(ic, es, _), EventSetDecl(es, ev), PrivateForModuleExpr(composedMod, ev).	

	//// IC is either disjoint or equal to the IX
	[rule_Classes = '"error, msg: compatibility error> after composition the created interfaces are not disjoint or equal to the exported interfaces"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), CreatesForModuleExpr(composedMod, ic),
											ExportsForModuleExpr(composedMod, ix), InterfaceTypeDeclList(ic, icL), InterfaceTypeDeclList(ix, ixL), icL != ixL,
											InterfaceTypeDecl(ic, esc, _), EventSetDecl(esc, ev), InterfaceTypeDecl(ix, esx, _), EventSetDecl(esx, ev).

	//// for the match IC and IX, constructor(IC) subtype of constructor(IX).
	[rule_Classes = '"error, msg: compatibility error> after composition the constructor type of created interfaces is not a subtype of constructor type of exported interfaces"']
	ModuleCompositionIllegal(modL, modR) :- AllCompositionExprs(modL, modR, emodL, emodR), composedMod = ComposeExpr(emodL, emodR), CreatesForModuleExpr(composedMod, ic),
											ExportsForModuleExpr(composedMod, ix), InterfaceTypeDeclList(ic, icL), InterfaceTypeDeclList(ix, ixL), icL = ixL,
											InterfaceTypeDecl(ic, _, ct), InterfaceTypeDecl(ix, _, xt), TypeRel(ct, xt, k), ct != xt, k != SUB.				

	/**************************************************************************/
	/*			Well-formedness condition check for the leaf modules		  */
	/**************************************************************************/
	WellFormednessError ::= (mod: ModuleDecl, sig: String).

	//// ix is not disjoint from EP
	[rule_Classes = '"error, msg: wellformedness error> the exported interfaces are not disjoint from private events"']
	WellFormednessError(mod, ix) :- mod is ModuleDecl, ExportsForModuleExpr(mod, ix), PrivateForModuleExpr(mod, ev), InterfaceTypeDecl(ix, es, _), EventSetDecl(es, ev).

	//// ic is not disjoint from EP
	[rule_Classes = '"error, msg: wellformedness error> the created interfaces are not disjoint from private events"']
	WellFormednessError(mod, ic) :- mod is ModuleDecl, CreatesForModuleExpr(mod, ic), PrivateForModuleExpr(mod, ev), InterfaceTypeDecl(ic, es, _), EventSetDecl(es, ev).

	//// IC is either disjoint or equal to the IX
	[rule_Classes = '"error, msg: wellformedness error> the created interfaces are not disjoint or equal to the exported interface"']
	WellFormednessError(mod, ix) :- mod is ModuleDecl, CreatesForModuleExpr(mod, ic), ExportsForModuleExpr(mod, ix), InterfaceTypeDeclList(ic, icL), InterfaceTypeDeclList(ix, ixL), 									icL != ixL, InterfaceTypeDecl(ic, esc, _), EventSetDecl(esc, ev), InterfaceTypeDecl(ix, esx, _), EventSetDecl(esx, ev).

	//// for the match IC and IX, constructor(IC) subtype of constructor(IX).
	[rule_Classes = '"error, msg: wellformedness error> type of created interfaces is not a subtype of constructor type of exported interface"']
	WellFormednessError(mod, ix) :- mod is ModuleDecl, CreatesForModuleExpr(mod, ic), ExportsForModuleExpr(mod, ix), 
									InterfaceTypeDeclList(ic, icL), InterfaceTypeDeclList(ix, ixL), icL = ixL,
									InterfaceTypeDecl(ic, _, ct), InterfaceTypeDecl(ix, _, xt), TypeRel(ct, xt, k), ct != xt, k != SUB.

	//// e \in ER + ES, all a in A(e) is disjoint from EP
	[rule_Classes = '"error, msg: wellformedness error> the public events in receives or sends has private permissions in them"']
	WellFormednessError(mod, mod.name) :- mod is ModuleDecl, ReceivesForModuleExpr(mod, ev), 
										  EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(mod, perm);
										  mod is ModuleDecl, SendsForModuleExpr(mod, ev),
										  EventDecl(ev, _, pt), EmbeddedPermissionsInType(pt, perm), PrivateForModuleExpr(mod, perm).


	/**************************************************************************/
	/*			Refinement, Implementation and Test Decls are legal			  */
	/**************************************************************************/
	TestOrImplDeclError ::= (modExpr : ModuleExpr).

	////Implementation and test module expr must be closed with respect to creates

	/**************************************************************************/
	/*			Populate all the maps used for code generation				  */
	/**************************************************************************/

	/**************************************************************************/
	/*     C Code Helpers
	/**************************************************************************/
	//implementation module functions
	ImplFunction ::= (f: FunDecl + AnonFunDecl).
	ImplFunction(f) :- f is FunDecl( _, mod, _, _, _, _, _, _),  AllImplModules(mod);
					   f is FunDecl, f.owner.kind = REAL, AllImplMachine(f.owner);
					   f is AnonFunDecl(mod, _, _, _),  AllImplModules(mod);
					   f is AnonFunDecl, f.owner.kind = REAL, AllImplMachine(f.owner).

	//all machines in implementation modules list
	AllImplMachine ::= (mach: MachineDecl).
	AllImplMachine(m) :- AllModuleDecls(emodExpr, mod), ImplementationDecl(modExpr), ModuleExprExpansion(modExpr, emodExpr), m is MachineDecl(_, mod, _, _, _, _), m.kind != MONITOR.
	AllImplModules ::= (mod: ModuleDecl).
	AllImplModules(mod) :- AllModuleDecls(emodExpr, mod), ImplementationDecl(modExpr), ModuleExprExpansion(modExpr, emodExpr).

	//FIX ME
	MapInterfaceToMachine ::= (mname: String, iname: String).

	/**************************************************************************/
	/*		populate the sends, receives and creates list for each machine	  */
	/**************************************************************************/
	//populate the sends for machines without send decl
	MachineSendsDecl(m, s) :- MachineSendsEventAll(m), EventDecl(s, _, _);
							  MachineSendsEventAll(m), s = HALT.

	//populate receives for machines with exports and no receives
	MachineReceivesDecl(m, ev) :- MachineExportsDecl(m, i), InterfaceTypeDecl(i, es, _), EventSetDecl(es, ev).
	
	//calculate creates for all FunDecls and AnonFunDecls
	CreatesForFunctions ::= (f: TypingContext, ic: String).

	//Comment reusing SubSE
	CreatesForFunctions(f, ic) :- SubSE(f, e), e = New(ic, _), InterfaceTypeDecl(ic, _, _);
								  SubSE(f, e), e = NewStmt(ic, _, _), InterfaceTypeDecl(ic, _, _);
								  SubSE(f, e), e : FunStmt, f' is FunDecl, e.name = f'.name, e.mod = NIL, f.owner = f'.owner, CreatesForFunctions(f', ic);
								  SubSE(f, e), e : FunStmt, f' is FunDecl, e.name = f'.name, f'.owner = ModuleDecl(e.mod), CreatesForFunctions(f', ic);
								  SubSE(f, e), e : FunApp, f' is FunDecl, e.name = f'.name, e.mod = NIL, f.owner = f'.owner, CreatesForFunctions(f', ic);
								  SubSE(f, e), e : FunApp, f' is FunDecl, e.name = f'.name, f'.owner = ModuleDecl(e.mod), CreatesForFunctions(f', ic).

	//populate the creates list for machine.
	MachineCreatesDecl(mach, ic) :- f is FunDecl, f.owner = mach, CreatesForFunctions(f, ic), mach : MachineDecl;
									af is AnonFunDecl, af.owner = mach, CreatesForFunctions(af, ic), mach : MachineDecl.

	//Checking the constructor type error for each exported interface
	ConstructorTypeError ::= (ex: MachineExportsDecl).
	[rule_Classes = '"error, msg: the constructor argument type is not a subtype of the exported interface argument type"']
	ConstructorTypeError(ex) :- ex is MachineExportsDecl(m, i), InterfaceTypeDecl(i, _, iargt), ConstructorType(m, _, ct), TypeRel(iargt, ct, k), ct != iargt, k != SUB. 						 
    
	/*************************************************************/
    /*                      Types of Expressions                 */
    /*************************************************************/
    
    //// (1) The types of nullary expressions
    TypeOf(c, e, BaseType(NULL))  :- SubSE(c, e), e = NulApp(NULL).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = NulApp(HALT).
	
	
	// Type of THIS is the receive set implemented by the machine, machine type if the receive set is empty.
    TypeOf(c, e, i)  :- SubSE(c, e), e = NulApp(THIS), c.owner != NIL, i = toList(#InterfaceType, NIL, {ev | MachineReceivesDecl(c.owner, ev)}), i : InterfaceType;
						SubSE(c, e), e = NulApp(THIS), c.owner != NIL, no MachineReceivesDecl(c.owner, _), i = BaseType(REAL).
    
	//"this" is not allowed in static functions
	[ rule_Classes = '"error, msg: "this" is not allowed in static functions"']
	TypeOf(c, e, ERROR)  :- SubSE(c, e), e = NulApp(THIS), c.owner = ModuleDecl(_).

	TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(NONDET).

    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(FAIRNONDET).
	    
    TypeOf(c, e, BaseType(INT))   :- SubSE(c, e), e = NulApp(v), v : Integer.
    TypeOf(c, e, BaseType(BOOL))  :- SubSE(c, e), e = NulApp(v), v : Boolean.          
    
    //// (2) The types of unary expressions
    TypeOf(c, e, et)              :- SubSE(c, e), e = Default(t), TypeExpansion(t, et). 
	
    TypeOf(c, e, t1)              :- TypeOfArg1(c, e, t1), e : Tuple.     

    TypeOf(c, e, t1)              :- TypeOfArg1(c, e, t1), e : NamedTuple.

	// Names can hide other names in the following order: local variable hides machine variable hides event
    IsLocalVar ::= (TypingContext, String, TypeExpr).
    IsLocalVar(c, n, et) :- SubSE(c, e), e = Name(n), TypeOfLocalVar(c, n, t), TypeExpansion(t, et).

    VarDeclExp ::= (VarDecl, TypeExpr).
    VarDeclExp(decl, et) :- decl is VarDecl(_, _, t), TypeExpansion(t, et).
    IsMachineVar ::= (TypingContext, String, VarDecl, TypeExpr).
    IsMachineVar(c, n, decl, et) :- SubSE(c, e), e = Name(n), VarDeclExp(decl, et), decl = VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _).

    IsEventCnst ::= (TypingContext, String, TypeExpr).
    IsEventCnst(c, n, BaseType(NULL)) :- SubSE(c, e), e = Name(n), EventDecl(n, _, NIL), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 
    IsEventCnst(c, n, pt)             :- SubSE(c, e), e = Name(n), EventDecl(n, _, t), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _), TypeExpansion(t, pt).

	TypeOf(c, e, et)              :- SubSE(c, e), e = Name(n), IsLocalVar(c, n, et).
    TypeOf(c, e, et)              :- SubSE(c, e), e = Name(n), IsMachineVar(c, n, _, et).
    TypeOf(c, e, BaseType(EVENT)) :- SubSE(c, e), e = Name(n), IsEventCnst(c, n, _).


	[ rule_Classes = '"error, msg: Undefined symbol"']
    TypeOf(c, e, ERROR)           :- SubSE(c, e), e = Name(n), no EventDecl(n, _, _), no VarDecl(n, c.owner, _), no TypeOfLocalVar(c, n, _). 
    
    TypeOf(c, e, BaseType(BOOL))  :- TypeOfArg1(c, e, t1), e = UnApp(NOT, _), t1 = BaseType(BOOL). 
	[ rule_Classes = '"error, msg: Operator expected a boolean value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(NOT, _), t1 != BaseType(BOOL). 
    
    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(NEG, _), t1 = BaseType(INT). 
	[ rule_Classes = '"error, msg: Operator expected an integer value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(NEG, _), t1 != BaseType(INT). 
    
    TypeOf(c, e, SeqType(dom))    :- TypeOfArg1(c, e, t1), e = UnApp(KEYS, _), t1 = MapType(dom, _). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(KEYS, _), toSymbol(t1) != #MapType. 

    TypeOf(c, e, SeqType(cod))    :- TypeOfArg1(c, e, t1), e = UnApp(VALUES, _), t1 = MapType(_, cod). 
	[ rule_Classes = '"error, msg: Operator expected a map value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(VALUES, _), toSymbol(t1) != #MapType. 

    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), t1 : MapType. 
    TypeOf(c, e, BaseType(INT))   :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), t1 : SeqType. 
	[ rule_Classes = '"error, msg: Operator expected a map or sequence value"']
    TypeOf(c, e, ERROR)           :- TypeOfArg1(c, e, t1), e = UnApp(SIZEOF, _), toSymbol(t1) != #MapType, toSymbol(t1) != #SeqType. 
    
    //// (3) The types of binary expressions
    TypeOf(c, e, t2')              :- TypeOfArg1(c, e, t1), e = Cast(_, t2), TypeExpansion(t2, t2'), TypeRel(t1, t2', k), k != EMPTY.
	[ rule_Classes = '"error, msg: Cast can never succeed"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = Cast(_, t2), TypeExpansion(t2, t2'), TypeRel(t1, t2', k), k = EMPTY.

    TypeOf(c, e, t)   :- SubSE(c, e), e = New(n, _), MachineDecl(n, _, mt, _, _, _), mt != MONITOR, no MachineReceivesDecl(c.owner, _), t = BaseType(REAL);
						 SubSE(c, e), e = New(n, _), no MachineDecl(n, _, _, _, _, _), MachineExportsDecl(_, n), TypeExpansion(NameType(n), t);
						 SubSE(c, e), e = New(n, _), MachineDecl(n, _, _, _, _, _), MachineReceivesDecl(m, _), MachineExportsDecl(_, n), TypeExpansion(NameType(n), t).

	[ rule_Classes = '"error, msg: Monitor cannot be created"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), MachineDecl(n, _, MONITOR, _, _, _).
	[ rule_Classes = '"error, msg: Undefined machine or no machine exports the created interface"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), no MachineDecl(n, _, _, _, _, _), no MachineExportsDecl(_, n).
	[ rule_Classes = '"error, msg: "new" of a machine is allowed only if the machine has empty receive set"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = New(n, _), m is MachineDecl(n, _, _, _, _, _), MachineReceivesDecl(m, _), no MachineExportsDecl(_, n).

	

    TypeOf(c, e, t2)               :- TypeOfArg2(c, e, _, t2), e : Field, t2 != ERROR.
	[ rule_Classes = '"error, msg: Bad field name"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, _, t2), e : Field, t2 = ERROR.
	[ rule_Classes = '"error, msg: Operator expected a (named) tuple value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Field, toSymbol(t1) != #TupType, toSymbol(t1) != #NmdTupType.
    
    PureIntOp ::= { ADD, SUB, MUL, INTDIV }.
    TypeOf(c, e, bint)             :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PureIntOp, t1 = bint, t2 = bint, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureIntOp, t1 != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), op : PureIntOp, TypeOf(c, e2, t2), t2 != BaseType(INT).     
    
    PureIntRel ::= { LT, LE, GT, GE }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, e', e''), op : PureIntRel, t1 = bint, t2 = bint, bint = BaseType(INT).
	[ rule_Classes = '"error, msg: Operator expected first argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureIntRel, t1 != BaseType(INT).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be an integer value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), TypeOf(c, e2, t2), op : PureIntRel, t2 != BaseType(INT).    
    
    PureBoolOp ::= { AND, OR }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PureBoolOp, t1 = bbool, t2 = bbool, bbool = BaseType(BOOL).
	[ rule_Classes = '"error, msg: Operator expected first argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(op, _, _), op : PureBoolOp, t1 != BaseType(BOOL).    
	[ rule_Classes = '"error, msg: Operator expected second argument to be a boolean value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(op, _, e2), TypeOf(c, e2, t2), op : PureBoolOp, t2 != BaseType(BOOL).    
    
    PolyRel ::= { EQ, NEQ }.
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t1, t2, k), k != EMPTY.
	[ rule_Classes = '"error, msg: Values cannot be compared because their types are incompatible"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel, TypeRel(t1, t2, k), k = EMPTY.
    
    TypeOf(c, e, inner)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = SeqType(inner), t2 = BaseType(INT).
    TypeOf(c, e, cod)              :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).
	[ rule_Classes = '"error, msg: Indexer must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinApp(IDX, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
	[ rule_Classes = '"error, msg: Index must be an integer"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 : SeqType, t2 != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, _), TypeRel(t2, dom, k), t2 != dom, k != SUB.
    
    TypeOf(c, e, BaseType(BOOL))   :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = MapType(dom, _), TypeRel(t1, dom, k), k != EMPTY.        
	[ rule_Classes = '"error, msg: Value can never be in the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _),  t2 = MapType(dom, _), TypeRel(t1, dom, EMPTY).        
	[ rule_Classes = '"error, msg: "in" expects a map"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = BinApp(IN, _, e2),  TypeOf(c, e2, t2), toSymbol(t2) != #MapType.
    
	///// (4) Exprs produces a tuple type
	TypeOf(c, e, t) :- TypeOfArg1(c, e, t1), e = Exprs(_, _, NIL), t = TupType(t1, NIL).
	TypeOf(c, e, t) :- TypeOfArg2(c, e, t1, t2), e : Exprs, t2 : TupType, t = TupType(t1, t2).
		
	//// (5) NamedExprs produces a named tuple type.
	TypeOf(c, e, t) :- TypeOfArg1(c, e, t1), e = NamedExprs(n, _, NIL), t = NmdTupType(NmdTupTypeField(NONE, n, t1), NIL).
	TypeOf(c, e, t) :- TypeOfArg2(c, e, t1, t2), e = NamedExprs(n, _, _), t2 : NmdTupType, t = NmdTupType(NmdTupTypeField(NONE, n, t1), t2).
	
	//// (6) FunApps must refer to a defined function that has a non-NIL return type and args must be sub-types of function signature. 
	TypeOf(c, e, et) :- SubSE(c, e), e = FunApp(n, NIL, NIL), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, NIL, et), et != NIL.
	TypeOf(c, e, et) :- SubSE(c, e), e = FunApp(n, m, NIL), m : String, decl.name = n, decl.owner = ModuleDecl(m), FunAvailable(decl, c.owner), FuncSig(decl, NIL, et), et != NIL.
	TypeOf(c, e, et) :- TypeOfArg1(c, e, t1), e = FunApp(n, NIL, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, et), et != NIL, TypeRel(t1, inpt, SUB).
	TypeOf(c, e, et) :- TypeOfArg1(c, e, t1), e = FunApp(n, m, _), m : String, FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, et), et != NIL, TypeRel(t1, inpt, SUB).

	[ rule_Classes = '"error, msg: function not defined"'] 
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL, _), no FunDecl(n, c.owner, _, _, _, _, _, _).
	[ rule_Classes = '"error, msg: static function can only call other static funtions"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL, _), toSymbol(c.owner) = #ModuleDecl.

	[ rule_Classes = '"error, msg: called function is not a public static function (its declared as private)"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, m, _), toSymbol(c.owner) = #ModuleDecl, c.owner != ModuleDecl(m), FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE);
						   SubSE(c, e), e = FunApp(n, m, _), toSymbol(c.owner) = #MachineDecl, c.owner.mod != ModuleDecl(m), FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE).

	[ rule_Classes = '"error, msg: public static function can only call other public static funtions"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, m, _), m : String, c.isPublic = TRUE, FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE).
	[ rule_Classes = '"error, msg: module does not implement the static function"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, m, _), m : String, ModuleDecl(m), no FunDecl(n, ModuleDecl(m), _, _, _, _, _, _).
	[ rule_Classes = '"error, msg: module not declared"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, m, _), m : String, no ModuleDecl(m).

	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, decl.return = NIL;
						   SubSE(c, e), e = FunApp(n, m, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), decl.return = NIL.

	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunApp(n, NIL, NIL), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, decl.params != NIL;
						   SubSE(c, e), e = FunApp(n, m, NIL), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), decl.params != NIL.
	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- TypeOfArg1(c, e, t1), e = FunApp(n, NIL, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, _), TypeRel(t1, inpt, k), t1 != inpt, k != SUB;
						   TypeOfArg1(c, e, t1), e = FunApp(n, m, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, _), TypeRel(t1, inpt, k), t1 != inpt, k != SUB.
	

    /*************************************************************/
	/*                      Qualifier Checking                   */
    /*************************************************************/

	AccessesGlobal ::= (TypingContext, String).
	AccessesGlobal(c, n) :- SubSE(c, e), e = Name(n), IsMachineVar(c, n, _, _).
	AccessesGlobal(c, n) :- SubSE(c, e), e = FunApp(calleeName, _, _), FunAvailable(callee, c.owner), callee.name = calleeName, AccessesGlobal(callee, n).
	AccessesGlobal(c, n) :- SubSE(c, e), e = FunStmt(calleeName, _, _, _, _, _), FunAvailable(callee, c.owner), callee.name = calleeName, AccessesGlobal(callee, n).

	FunDeclQualifierError ::= (FunDecl, String).
	[ rule_Classes = '"error, msg: xfer not allowed"']
	FunDeclQualifierError(c, name) :- FormalParamAux(c, XFER, name, _).

	FunArgsParams ::= (TypingContext, FunApp + FunStmt, Exprs + { NIL }, NmdTupType + { NIL }).
	FunArgsParams(c, e, e.args, decl.params) :- TypeOfArg1(c, e, t1), e: FunApp, FunAvailable(decl, c.owner), decl.name = e.name, FuncSig(decl, inpt, _), TypeRel(t1, inpt, SUB).
	FunArgsParams(c, e, e.args, decl.params) :- TypeOfArg1(c, e, t1), e: FunApp, FunAvailable(decl, c.owner), decl.name = e.name, FuncSig(decl, t1, _).
	FunArgsParams(c, e, e.args, decl.params) :- TypeOfArg1(c, e, t1), e: FunStmt, FunAvailable(decl, c.owner), decl.name = e.name, FuncSig(decl, inpt, _), TypeRel(t1, inpt, SUB).
	FunArgsParams(c, e, e.args, decl.params) :- TypeOfArg1(c, e, t1), e: FunStmt, FunAvailable(decl, c.owner), decl.name = e.name, FuncSig(decl, t1, _).
	FunArgsParams(c, e, exprs, nmdTupType) :- FunArgsParams(c, e, exprs', nmdTupType'), exprs' = Exprs(_, _, exprs), nmdTupType' = NmdTupType(_, nmdTupType).

	FunCallQualifierError ::= (TypingContext, FunApp + FunStmt, Expr).
	[ rule_Classes = '"error, msg: argument qualifier incompatible with parameter qualifier"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, nmdTupType), exprs = Exprs(REF, expr, _), nmdTupType = NmdTupType(NmdTupTypeField(NONE, _, _), _).
	[ rule_Classes = '"error, msg: argument qualifier incompatible with parameter qualifier"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, nmdTupType), exprs = Exprs(qual, expr, _), qual != REF, nmdTupType = NmdTupType(NmdTupTypeField(REF, _, _), _).
	[ rule_Classes = '"error, msg: argument qualifier xfer not allowed in nested function call"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, _), e: FunApp, exprs = Exprs(XFER, expr, _).

	[ rule_Classes = '"error, msg: argument should be a variable"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, _), exprs = Exprs(qual, expr, _), qual != NONE, toSymbol(expr) != #Name.
	[ rule_Classes = '"error, msg: argument should be a variable"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, _), exprs = Exprs(qual, expr, _), qual != NONE, expr = Name(n), IsEventCnst(c, n, _).
	[ rule_Classes = '"error, msg: argument should be a local variable"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, _), exprs = Exprs(XFER, expr, _), expr = Name(n), IsMachineVar(c, n, _, _).
	[ rule_Classes = '"error, msg: argument should be a global variable not accessed by callee"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, exprs, _), FunAvailable(callee, c.owner), e.name = callee.name, 
										 exprs = Exprs(REF, expr, _), expr = Name(n), IsMachineVar(c, n, _, _), AccessesGlobal(callee, n).
	[ rule_Classes = '"error, msg: xfer or swap argument should be passed for exactly one parameter"']
	FunCallQualifierError(c, e, expr) :- FunArgsParams(c, e, Exprs(qual, expr, tl), _), FunArgsParams(c, e, Exprs(_, expr, tl'), _), qual != NONE, tl != tl'.

	SendQualifierError ::= (TypingContext, Send).
	[rule_Classes = '"error, msg: swap qualifier not allowed"']
	SendQualifierError(c, e) :- SubSE(c, e), e = Send(_, _, _, REF, _).
	[ rule_Classes = '"error, msg: null payload not allowed"']
	SendQualifierError(c, e) :- SubSE(c, e), e = Send(_, _, NIL, XFER, _).
	[ rule_Classes = '"error, msg: payload should be a variable"']
	SendQualifierError(c, e) :- SubSE(c, e), e = Send(_, _, expr, XFER, _), toSymbol(expr) != #Name.
	[ rule_Classes = '"error, msg: payload should be a variable"']
	SendQualifierError(c, e) :- SubSE(c, e), e = Send(_, _, expr, XFER, _), expr = Name(n), IsEventCnst(c, n, _).
	[ rule_Classes = '"error, msg: payload should be a local variable"']
	SendQualifierError(c, e) :- SubSE(c, e), e = Send(_, _, expr, XFER, _), expr = Name(n), IsMachineVar(c, n, _, _).

	EnvVars ::= (AnonFunDecl, String, NmdTupType + { NIL }).
	EnvVars(c, n, envVars) :- c is AnonFunDecl(_, _, _, NmdTupType(NmdTupTypeField(_, n, _), envVars)), envVars != NIL.
	EnvVars(c, n, envVars) :- EnvVars(c, _, NmdTupType(NmdTupTypeField(_, n, _), envVars)), envVars != NIL.

	UnavailableBefore ::= (TypingContext, Stmt + Cases, String).
	UnavailableAfter  ::= (TypingContext, Stmt + Cases, String).
	
	UnavailableBefore(c, s2, n)   :- SubSE(c, Seq(s1, s2)), UnavailableAfter(c, s1, n).
	UnavailableAfter(c, s, n)     :- SubSE(c, s), s = Seq(_, s'), UnavailableAfter(c, s', n).
	UnavailableBefore(c, s', n)   :- SubSE(c, s), s = Seq(s', _), UnavailableBefore(c, s, n).

	UnavailableBefore(c, s, n)  :- SubSE(c, s), s = While(_, s', _), UnavailableAfter(c, s', n).
	UnavailableBefore(c, s, n)  :- SubSE(c, s'), s' = While(_, s, _), UnavailableBefore(c, s', n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: While, UnavailableBefore(c, s, n).
	
	UnavailableBefore(c, s, n)  :- SubSE(c, s'), s' = Ite(_, s, _, _), UnavailableBefore(c, s', n); 
								   SubSE(c, s'), s' = Ite(_, _, s, _), UnavailableBefore(c, s', n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = Ite(_, s', _, _), UnavailableAfter(c, s', n); 
								   SubSE(c, s), s = Ite(_, _, s', _), UnavailableAfter(c, s', n).

	UnavailableBefore(c, cases, n)  :- ReceiveCases(c, s, cases), UnavailableBefore(c, s, n).
	UnavailableBefore(c', s, n)     :- UnavailableBefore(c, cases, n), cases = Cases(_, c', _), s = c'.body.
	UnavailableAfter(c, s, n)       :- ReceiveCases(c, s, cases), cases = Cases(_, c', _), UnavailableAfter(c', c'.body, n), EnvVars(c', n, _).

	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: NewStmt, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: Announce, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: Assert, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: Print, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = NulStmt(SKIP, _), UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: FunStmt, UnavailableBefore(c, s, n), s.aout != Name(n).
	UnavailableAfter(c, s, n)   :- FunArgsParams(c, s, Exprs(XFER, Name(n), _), _), s: FunStmt, s.aout != Name(n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s: Send, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = Send(_, _, Name(n), XFER, _).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = BinStmt(op, _, _, _), op != ASSIGN, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = BinStmt(ASSIGN, e, _, _), toSymbol(e) != #Name, UnavailableBefore(c, s, n).
	UnavailableAfter(c, s, n)   :- SubSE(c, s), s = BinStmt(ASSIGN, Name(n'), _, _), UnavailableBefore(c, s, n), n' != n.

	SubExpr ::= sub (TypingContext, Stmt + Expr + Exprs, Expr).
	
	UnavailableVarAccessError ::= (TypingContext, Stmt, String).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: NewStmt, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: Raise, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: Send, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: FunStmt, SubExpr(c, s.args, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s = BinStmt(op, _, _, _), op != ASSIGN, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s = BinStmt(ASSIGN, arg, _, _), toSymbol(arg) != #Name, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s = BinStmt(ASSIGN, Name(_), arg, _), SubExpr(c, arg, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: Return, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s = While(e, _, _), SubExpr(c, e, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s = Ite(e, _, _, _), SubExpr(c, e, Name(n)), UnavailableBefore(c, s, n).
	[rule_Classes = '"error, msg: variable is not available"']
	UnavailableVarAccessError(c, s, n) :- SubSE(c, s), s: Assert, SubExpr(c, s, Name(n)), UnavailableBefore(c, s, n).

	UnavailableParameterError ::= (FunDecl, String).
	[rule_Classes = '"error, msg: parameter is not available at return"']
	UnavailableParameterError(c, n) :- FormalParamAux(c, REF, n, _), UnavailableAfter(c, c.body, n).
	[rule_Classes = '"error, msg: parameter is not available at return"']
	UnavailableParameterError(c, n) :- FormalParamAux(c, REF, n, _), UnavailableBefore(c, Return(_, _), n).

    /*************************************************************/
    /*                      Types of Statements                  */
    /*************************************************************/

	//// (1) Nullary statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(SKIP, _).
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = NulStmt(POP, _).

	//// (2) Return statement
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL, _), c = FunDecl(_, _, _, _, NIL, _, _, _). 
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Return(NIL, _), c : AnonFunDecl.
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : Return, FuncSig(c, _, et), TypeRel(t1, et, SUB).
	[ rule_Classes = '"error, msg: function must return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(NIL, _), c = FunDecl(_, _, _, _, t, _, _, _), t != NIL. 
	[ rule_Classes = '"error, msg: function cannot return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(e1, _), e1 != NIL, c = FunDecl(_, _, _, _, NIL, _, _, _). 
	[ rule_Classes = '"error, msg: return value has incorrect type"' ]
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Return, FuncSig(c, _, et), TypeRel(t1, et, k), t1 != et, k != SUB.
	[ rule_Classes = '"error, msg: anonymous function cannot return a value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Return(e1, _), c : AnonFunDecl, e1 != NIL. 

	//// (3) Non-mutating statements
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Seq(_, _).
    
	TypeOf(c, e, NIL)              :- SubSE(c, e), e = Print(_, _).

    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e = Assert(_, _, _), t1 = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "assert" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = Assert(_, _, _), t1 != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : Ite, t1 = BaseType(BOOL).
	[ rule_Classes                                   = '"error, msg: "if (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Ite, t1 != BaseType(BOOL).
    
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e : While, t1 = BaseType(BOOL).
	[ rule_Classes = '"error, msg: "while (...)" expects a boolean value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : While, t1 != BaseType(BOOL).
    
	          
    TypeOf(c, e, NIL)   :- SubSE(c, e), e = NewStmt(n, _, _), no MachineDecl(n, _, _, _, _, _), MachineExportsDecl(_, n);
						   SubSE(c, e), e = NewStmt(n, _, _), MachineDecl(n, _, mt, _, _, _), mt != MONITOR, no MachineReceivesDecl(c.owner, _);
						   SubSE(c, e), e = NewStmt(n, _, _), MachineDecl(n, _, _, _, _, _), MachineReceivesDecl(m, _), MachineExportsDecl(_, n).
						  
	[ rule_Classes = '"error, msg: Monitor cannot be created"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _, _), MachineDecl(n, _, MONITOR, _, _, _).
	[ rule_Classes = '"error, msg: Undefined machine or no machine exports the created interface"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _, _), no MachineDecl(n, _, _, _, _, _), no MachineExportsDecl(_, n).
	[ rule_Classes = '"error, msg: "new" of a machine is allowed only if the machine has empty receive set"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = NewStmt(n, _, _), m is MachineDecl(n, _, _, _, _, _), MachineReceivesDecl(m, _), no MachineExportsDecl(_, n).

	//// Rules for raise.
    TypeOf(c, e, NIL)              :- CommStmtPLType(c, e, plt), e = Raise(_, NIL, _),              ///// < raise has NIL payload,
	                                  TypeRel(BaseType(NULL), plt, SUB).                          ///// < event type contains null.

    TypeOf(c, e, NIL)              :- CommStmtPLType(c, e, plt), e = Raise(_, p, _), p != NIL,      ///// < raise has non-NIL payload,             
	                                  TypeOf(c, p, pt), TypeRel(pt, plt, SUB).                    ///// < and pt is a subtype of evt.

	//// Error rules for raise.
	[ rule_Classes = '"error, msg: argument 1 of "raise" expects an event value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Raise, t1 != BaseType(EVENT).
	
    [ rule_Classes = '"error, msg: invalid payload type in raise (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- CommStmtPLType(c, e, plt), e = Raise(_, NIL, _), null = BaseType(NULL),  ///// < raise has NIL payload,
									  TypeRel(null, plt, k), k != SUB, null != plt.                         ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in raise"']
    TypeOf(c, e, ERROR)            :- CommStmtPLType(c, e, plt), e = Raise(_, p, _), p != NIL,       ///// < p has non-NIL payload,             
									  TypeOf(c, p, pt), TypeRel(pt, plt, k), k != SUB, pt != plt. ///// < and pt is not a subtype of plt.

	//// Rules for send.
    TypeOf(c, e, NIL)              :- TypeOfArg1(c, e, t1), e = Send(_, _, NIL, _, _),                     ///// < send has NIL payload,
	                                  TypeRel(t1, BaseType(REAL), SUB), t1 != BaseType(NULL),              ///// < arg1 is a subtype of machine type,
	                                  CommStmtPLType(c, e, plt), TypeRel(BaseType(NULL), plt, SUB).        ///// < arg2 event type contains null.

    TypeOf(c, e, NIL)              :- TypeOfArg3(c, e, t1, t2, t3), e : Send,                             ///// < send has non-NIL payload,             
									  TypeRel(t1, BaseType(REAL), SUB), t1 != BaseType(NULL),             ///// < arg1 is a subtype of machine type,
	                                  CommStmtPLType(c, e, plt), TypeRel(t3, evt, SUB).                   ///// < and t3 is a subtype of plt.

	//// Error rules for send.
	[ rule_Classes = '"error, msg: argument 1 of "send" expects a machine or interface type value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Send, toSymbol(t1) != #InterfaceType, t1 != BaseType(REAL).

	[ rule_Classes = '"error, msg: sent event is not in the sends list of the machine"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, e2, _, _, _), c.owner != NIL, e2 = Name(n), IsEventCnst(c, n, _), no MachineSendsDecl(c.owner, n).

	[ rule_Classes = '"error, msg: argument 2 of "send" expects an event value"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, e2, _, _, _), TypeOf(c, e2, t2), t2 != BaseType(EVENT).

	//// Error rules for send with constant event expression. 	
    [ rule_Classes = '"error, msg: invalid payload type in send (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Send(_, _, NIL, _, _), null = BaseType(NULL),   ///// < send has NIL payload,
	                                  CommStmtPLType(c, e, plt),                                  ///// < constant event expression
									  TypeRel(null, plt, k), k != SUB, null != plt.               ///// < and null not in event type.

	//// Rules for Announce.
    TypeOf(c, e, NIL)              :- SubSE(c, e), e = Announce(_, NIL, _),                           ///// < Announce has NIL payload,
	                                  CommStmtPLType(c, e, plt), TypeRel(BaseType(NULL), plt, SUB).  ///// < event type contains null.

    TypeOf(c, e, NIL)              :- TypeOfArg2(c, e, t1, t2), e = Announce(_, _, _),                          ///// < Announce has non-NIL payload,
	                                  CommStmtPLType(c, e, plt), TypeRel(t2, plt, SUB).                        ///// < and pt is a subtype of plt.

	//// Error rules for Announce.

	[ rule_Classes = '"error, msg: argument 1 of "Announce" expects an event value"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e : Announce, t1 != BaseType(EVENT).

	//// Error rules for Announce. 	
    [ rule_Classes = '"error, msg: invalid payload type in Announce (cannot send null value)"']
    TypeOf(c, e, ERROR)            :- SubSE(c, e), e = Announce(_, NIL, _), null = BaseType(NULL), ///// < Announce has NIL payload,
	                                  CommStmtPLType(c, e, plt),                                  ///// < constant event expression
									  TypeRel(null, plt, k), k != SUB, null != plt.               ///// < and null not in event type.

    [ rule_Classes = '"error, msg: invalid payload type in Announce"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e : Announce,    ///// < p has non-NIL payload,             
	                                  CommStmtPLType(c, e, plt),                ///// < constant event expression
									  TypeRel(t2, plt, k), k != SUB, t2 != plt. ///// < and pt is not a subtype of evt.

	//// (4) Mutating statements		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _, _), TypeRel(t2, t1, SUB).
	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e , ERROR)		   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _, _), TypeRel(t2, t1, k), k!= SUB, t1 != t2.
		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _, _), t1 : SeqType, t2 = BaseType(INT).
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _, _), t1 = MapType(dom, cod), TypeRel(t2, dom, SUB).	
	[ rule_Classes = '"error, msg: remove must be applied to a sequence or map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinStmt(REMOVE, _, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
    [ rule_Classes = '"error, msg: index must be an integer"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _, _), t1 : SeqType, t2 != BaseType(INT).
	[ rule_Classes = '"error, msg: Index may not be in the domain of the map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _, _), t1 = MapType(dom, _), TypeRel(t2, dom, k), t2 != dom, k != SUB.
		
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = SeqType(inner), t2 = TupType(BaseType(INT), TupType(value, NIL)), TypeRel(value, inner, SUB).
	TypeOf(c, e, NIL)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, SUB), TypeRel(key, dom, SUB).	
	[ rule_Classes = '"error, msg: insert must be applied to a sequence or a map"']
    TypeOf(c, e, ERROR)            :- TypeOfArg1(c, e, t1), e = BinStmt(INSERT, _, _, _), toSymbol(t1) != #SeqType, toSymbol(t1) != #MapType.
	[ rule_Classes = '"error, msg: for insert right syntax is seq += (index value) or map += (key value)"']
	TypeOf(c, e, ERROR)			   :- SubSE(c, e), e = BinStmt(INSERT, _, arg2, _), TypeOf(c, arg2, t2), toSymbol(t2) != #TupType; 
	                                  SubSE(c, e), e = BinStmt(INSERT, _, arg2, _), TypeOf(c, arg2, t2), t2 : TupType, lstLength(#TupType, t2) != 2.
    [ rule_Classes = '"error, msg: key must be an integer"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), idx != BaseType(INT).	
    [ rule_Classes = '"error, msg: value must be a subtype of sequence type"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)), TypeRel(value, inner, k), k != SUB, value != inner.	
	[ rule_Classes = '"error, msg: key not in the domain of the map"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(key, dom, k), k != SUB, key != dom.	
	[ rule_Classes = '"error, msg: value not in the codomain of the map"']
    TypeOf(c, e, ERROR)			   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)), TypeRel(value, cod, k), k != SUB, value != cod.
	
	//// (5) Function statements
	TypeOf(c, e, NIL)   :- SubSE(c, e), e = FunStmt(n, NIL, NIL, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, NIL, _);
						   SubSE(c, e), e = FunStmt(n, m, NIL, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, NIL, _).
	TypeOf(c, e, NIL)   :- TypeOfArg1(c, e, t1), e = FunStmt(n, NIL, _, NIL, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, _), TypeRel(t1, inpt, SUB);
						   TypeOfArg1(c, e, t1), e = FunStmt(n, m, _, NIL, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, _), TypeRel(t1, inpt, SUB).
	TypeOf(c, e, NIL)   :- TypeOfArg2(c, e, t1, t2), e = FunStmt(n, NIL, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, et), TypeRel(t1, inpt, SUB), TypeRel(et, t2, SUB);
						   TypeOfArg2(c, e, t1, t2), e = FunStmt(n, m, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, et), TypeRel(t1, inpt, SUB), TypeRel(et, t2, SUB).
	
	
	[ rule_Classes = '"error, msg: function not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL, _, _, _, _), no FunDecl(n, c.owner, _, _, _, _, _, _).
	[ rule_Classes = '"error, msg: static function can only call other static funtions"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL, _, _, _, _), toSymbol(c.owner) = #ModuleDecl.
	
	[ rule_Classes = '"error, msg: called function is not a public static function (its declared as private)"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, m, _, _, _, _), toSymbol(c.owner) = #ModuleDecl, c.owner != ModuleDecl(m), FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE);
						   SubSE(c, e), e = FunStmt(n, m, _, _, _, _), toSymbol(c.owner) = #MachineDecl, c.owner.mod != ModuleDecl(m), FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE).

	[ rule_Classes = '"error, msg: public static function can only call other public static funtions"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, m, _, _, _, _), m : String, c.isPublic = TRUE, FunDecl(n, ModuleDecl(m), _, _, _, _, _, FALSE).
	[ rule_Classes = '"error, msg: module does not implement the static function"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, m, _, _, _, _), m : String, ModuleDecl(m), no FunDecl(n, ModuleDecl(m), _, _, _, _, _, _).
	[ rule_Classes = '"error, msg: module not declared"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, m, _, _, _, _), m : String, no ModuleDecl(m).

	[ rule_Classes = '"error, msg: function requires arguments"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL, NIL, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, decl.params != NIL;
						   SubSE(c, e), e = FunStmt(n, m, NIL, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), decl.params != NIL.

	[ rule_Classes = '"error, msg: function arguments have incorrect types"']
	TypeOf(c, e, ERROR) :- TypeOfArg1(c, e, t1), e = FunStmt(n, NIL, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, _), TypeRel(t1, inpt, k), t1 != inpt, k != SUB;
						   TypeOfArg1(c, e, t1), e = FunStmt(n, m, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, _), TypeRel(t1, inpt, k), t1 != inpt, k != SUB.

	[ rule_Classes = '"error, msg: function does not return a value"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = FunStmt(n, NIL, _, x, _, _), x: Name, FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, decl.return = NIL;
						   SubSE(c, e), e = FunStmt(n, m, _, x, _, _), x: Name, FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), decl.return = NIL.

	[ rule_Classes = '"error, msg: invalid assignment. right hand side is not a subtype of left hand side"']
	TypeOf(c, e, ERROR) :- TypeOfArg2(c, e, t1, t2), e = FunStmt(n, NIL, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, _, et), TypeRel(et, t2, k), k != SUB, et != t2;
						   TypeOfArg2(c, e, t1, t2), e = FunStmt(n, m, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, _, et), TypeRel(et, t2, k), k != SUB, et != t2.
	//// (6) Receive statement
	ReceiveCases ::= (c: TypingContext, receive: Receive, cases: Cases).
	ReceiveCases(c, receive, cases) :- SubSE(c, receive), receive = Receive(cases, _, _).
	ReceiveCases(c, receive, cases) :- ReceiveCases(c, receive, Cases(_, _, cases)), cases : Cases.

	[ rule_Classes = '"error, msg: two cases with the same event not allowed"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e: Receive, ReceiveCases(c, e, case1), ReceiveCases(c, e, case2), case1 != case2, case1.trig = case2.trig.
	// This error is covered by one of the cases
	TypeOf(c, e, ERROR) :- SubSE(c, e), e: Receive, ReceiveCases(c, e, cases), TypeOf(c, cases, ERROR).

	ValidCaseEvent ::= (trig: String + { NULL, HALT }).
	ValidCaseEvent(trig) :- trig = NULL.
	ValidCaseEvent(trig) :- trig = HALT.
	ValidCaseEvent(trig) :- trig: String, EventDecl(trig, _, _).

	[ rule_Classes = '"error, msg: event not defined"']
	TypeOf(c, e, ERROR) :- SubSE(c, e), e = Cases(trig, _, _), trig: String, no EventDecl(trig, _, _).
	
	TypeOf(c, e, NIL) :- SubSE(c, e), e = Cases(trig, _, _), ValidCaseEvent(trig).

    /*************************************************************/
    /*                     Types of arguments                    */
    /*************************************************************/

	//// The type of the first sub-expression in a Typeable with at least one sub-expression.
    TypeOfArg1 ::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = New(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = FunApp(_, _, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = UnApp(_, e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Cast(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Tuple(e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NamedTuple(e1), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NewStmt(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = FunStmt(_, _, e1, _, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Assert(e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Return(e1, _), TypeOf(c, e1, t1).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Field(e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = While(e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = BinStmt(_, e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = BinApp(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Exprs(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = NamedExprs(_, e1, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Raise(e1, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Announce(e1, _, _), TypeOf(c, e1, t1).

	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Send(e1, _, _, _, _), TypeOf(c, e1, t1).
	TypeOfArg1(c, e, t1) :- SubSE(c, e), e = Ite(e1, _, _, _), TypeOf(c, e1, t1).

	//// The type of the first two sub-expression in a Typeable with at least two sub-expression.
    TypeOfArg2::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }, type2: TypeExpr + { ERROR, NIL }).

	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Field(_, n), TypeOfField(t1, n, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = FunStmt(_, _, _, e2, _, _), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = BinStmt(_, _, e2, _), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = BinApp(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Exprs(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = NamedExprs(_, _, e2), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Raise(_, e2, _), TypeOf(c, e2, t2).
	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Announce(_, e2, _), TypeOf(c, e2, t2).

	TypeOfArg2(c, e, t1, t2) :- TypeOfArg1(c, e, t1), e = Send(_, e2, _, _, _), TypeOf(c, e2, t2).

	//// The type of the first three sub-expression in a Typeable with at least three sub-expression.
    TypeOfArg3::= (cntxt: TypingContext, expr: Typeable, type1: TypeExpr + { ERROR, NIL }, type2: TypeExpr + { ERROR, NIL }, type3: TypeExpr + { ERROR, NIL }).

	TypeOfArg3(c, e, t1, t2, t3) :- TypeOfArg2(c, e, t1, t2), e = Send(_, _, e3, _, _), TypeOf(c, e3, t3).

	//// Determines the payload type of the event mentioned in a communication statement.
	//// If the event expression is not an constant, then this payload type is ANY.
	CommStmtPLType ::= (cntxt: TypingContext, comm: Raise + Send + Announce, type: TypeExpr + { ERROR }).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Raise(ev, _, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Raise(ev, _, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), toSymbol(ev) != #Name.
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Raise(ev, _, _), ev = Name(n), IsEventCnst(c, n, plt).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Send(_, ev, _, _, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Send(_, ev, _, _, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), toSymbol(ev) != #Name.
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Send(_, ev, _, _, _), ev = Name(n), IsEventCnst(c, n, plt).

	CommStmtPLType(c, e, ERROR)         :- SubSE(c, e), e = Announce(ev, _, _), TypeOf(c, ev, evt), evt != BaseType(EVENT).
	CommStmtPLType(c, e, BaseType(ANY)) :- SubSE(c, e), e = Announce(ev, _, _), TypeOf(c, ev, evt), evt = BaseType(EVENT), toSymbol(ev) != #Name.
	CommStmtPLType(c, e, plt)           :- SubSE(c, e), e = Announce(ev, _, _), ev = Name(n), IsEventCnst(c, n, plt).

    /*************************************************************/
    /*                      Field helpers                        */
    /*************************************************************/

	TOrNTType      ::= TupType + NmdTupType.
	FieldLabel     ::= String + Natural.
    TypeOfField    ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }).    
    TypeOfFieldAux ::= (tupTyp: TOrNTType, lookup: FieldLabel, fieldType: TypeExpr + { ERROR }, pos: Natural, tail: TOrNTType + { NIL }).

    TypeOfFieldAux(ttup, n, ERROR, 0, ttup)  :- SubSE(c, e), e = Field(e', n), TypeOf(c, e', ttup), ttup : TOrNTType.    
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = TupType(t, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), n = pos, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, _, t), tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, ERROR, pos, aux), pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, n, t), tl).

    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, pos' = pos + 1, aux = TupType(_, tl).
    TypeOfFieldAux(ttup, n, t, pos', tl)     :- TypeOfFieldAux(ttup, n, t, pos, aux), n != pos, n != fn, pos' = pos + 1, aux = NmdTupType(NmdTupTypeField(_, fn, _), tl).

    TypeOfField(ttup, n, ft)                 :- TypeOfFieldAux(ttup, n, ft, _, NIL).    
	TypeOfField(ttup, n, ERROR)              :- TypeOfFieldAux(ttup, n, ERROR, 0, ttup), n : String, ttup : TupType.

	/*************************************************************/
    /*                  Local Variable Types                     */
    /*************************************************************/
	MaxNumLocals ::= (ctxt: TypingContext + Stmt + Cases, n: Natural).
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: NewStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Raise.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Send.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Announce.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: FunStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: NulStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Assert.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Print.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: BinStmt.
	MaxNumLocals(e, 0) :- SubSE(c, e), c is TypingContext, e: Return.
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = While(_, e', _), MaxNumLocals(e', n).
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Ite(_, e1, e2, _), 
						  MaxNumLocals(e1, n1), MaxNumLocals(e2, n2), n = max(n1, n2).
    MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Seq(e1, e2), 
	                      MaxNumLocals(e1, n1), MaxNumLocals(e2, n2), n = max(n1, n2).
	MaxNumLocals(e, n) :- SubSE(c, receive), c is TypingContext, receive: Receive, 
						  ReceiveCases(c, receive, e), e = Cases(_, a, NIL), MaxNumLocals(a, n).
	MaxNumLocals(e, n) :- SubSE(c, receive), c is TypingContext, receive: Receive, 
						  ReceiveCases(c, receive, e), e = Cases(_, a, e'), e': Cases, 
						  MaxNumLocals(a, n1), MaxNumLocals(e', n2), n =  max(n1, n2).
	MaxNumLocals(e, n) :- SubSE(c, e), c is TypingContext, e = Receive(cases, _, _), MaxNumLocals(cases, n). 
	MaxNumLocals(a, n) :- a is AnonFunDecl, MaxNumLocals(a.body, n1), n2 = lstLength(#NmdTupType, a.locals), n = n1 + n2 + 1.
	MaxNumLocals(a, n) :- a is FunDecl, MaxNumLocals(a.body, n1), n2 = lstLength(#NmdTupType, a.locals), n3 = lstLength(#NmdTupType, a.params), n = n1 + n2 + n3.

    LocalVarsAux ::= (cntxt: FunDecl + AnonFunDecl, vars: NmdTupType + { NIL }, tl: NmdTupType + { NIL }).
	LocalVarsAux(cntxt, envVars, locals) :- cntxt is FunDecl(_, _, _, params, _, locals, _, _), envVars = lstReverse(#NmdTupType, params).
	LocalVarsAux(cntxt, envVars, locals) :- cntxt is AnonFunDecl(_, locals, _, envVars'), envVars = lstReverse(#NmdTupType, envVars').
	LocalVarsAux(cntxt, envVars, locals) :- LocalVarsAux(cntxt, envVars', locals'), locals' = NmdTupType(NmdTupTypeField(qual, name, type), locals),
									        envVars = NmdTupType(NmdTupTypeField(qual, name, type), envVars').

	LocalVars ::= (cntxt: FunDecl + AnonFunDecl, vars: NmdTupType + { NIL }).
	LocalVars(cntxt, rlocals) :- LocalVarsAux(cntxt, locals, NIL), rlocals = lstReverse(#NmdTupType, locals).

	TypeOfLocalVar    ::= (cntxt: FunDecl + AnonFunDecl, name: String, type: TypeExpr + { ERROR }).
    TypeOfLocalVarAux ::= (cntxt: FunDecl + AnonFunDecl, name: String, type: TypeExpr, aux: NmdTupType + { NIL }).

    TypeOfLocalVarAux(cntxt, name, type, tl) :- LocalVars(cntxt, locals), locals = NmdTupType(NmdTupTypeField(_, name, type), tl).
    TypeOfLocalVarAux(cntxt, name, type, tl) :- TypeOfLocalVarAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(_, name, type), tl).
    
    TypeOfLocalVar(cntxt, name, type)  :- TypeOfLocalVarAux(cntxt, name, type, aux), no { aux' | TypeOfLocalVarAux(cntxt, name, _, aux'), aux != aux' }.
	[ rule_Classes = '"error, msg: Variable with same name has been declared before"']
    TypeOfLocalVar(cntxt, name, ERROR) :- TypeOfLocalVarAux(cntxt, name, _, aux), TypeOfLocalVarAux(cntxt, name, _, aux'), aux != aux'.

    /*************************************************************/
    /*                  Formal Parameter Types                   */
    /*************************************************************/
    FormalParam    ::= (cntxt: FunDecl, name: String).
    FormalParamAux ::= (cntxt: FunDecl, qual: Qualifier, name: String, aux: NmdTupType + { NIL }).
    
    FormalParamAux(cntxt, qual, name, tl) :- cntxt is FunDecl(_, _, _, params, _, _, _, _), params = NmdTupType(NmdTupTypeField(qual, name, _), tl).  
    FormalParamAux(cntxt, qual, name, tl) :- FormalParamAux(cntxt, _, _, aux), aux = NmdTupType(NmdTupTypeField(qual, name, _), tl).
    FormalParam(cntxt, name)  :- FormalParamAux(cntxt, _, name, _).

	//// The input type of a function, ignoring names.
	FuncSigTupleType    ::= (cntxt: FunDecl, type: TupType + { NIL }).
	FuncSigTupleTypeAux ::= (cntxt: FunDecl, type: TupType + { NIL }, aux: NmdTupType + { NIL }).

	FuncSigTupleTypeAux(cntxt, params, NIL) :- cntxt is FunDecl(_, _, _, params, _, _, _, _), params = NIL.
	FuncSigTupleTypeAux(cntxt, type, tl)    :- cntxt is FunDecl(_, _, _, params, _, _, _, _), params = NmdTupType(NmdTupTypeField(_, _, t), tl), TypeExpansion(t, et), type = TupType(et, NIL).
	FuncSigTupleTypeAux(cntxt, type, tl)    :- FuncSigTupleTypeAux(cntxt, t', aux), aux = NmdTupType(NmdTupTypeField(_, _, t), tl), TypeExpansion(t, et), type = TupType(et, t').
	FuncSigTupleType(cntxt, type)           :- FuncSigTupleTypeAux(cntxt, t, NIL), type = lstReverse(#TupType, t).

	FuncSig    ::= (cntxt: FunDecl, inputType: TupType + { NIL }, outputType: TypeExpr + { NIL }).
	FuncSig(cntxt, inputType, NIL) :- FuncSigTupleType(cntxt, inputType), cntxt.return = NIL.
	FuncSig(cntxt, inputType, et)  :- FuncSigTupleType(cntxt, inputType), TypeExpansion(cntxt.return, et).

    /*************************************************************/
    /* Check that named tuple (types) don't reuse the same name  */
    /*************************************************************/
	NmdList       ::= NmdTupType + NamedExprs.
	NmdListOrNone ::= NmdTupType + NamedExprs + { NIL }.

	NmdSubE     ::= sub (NmdList).
	MaxNmdSubE  ::=     (NmdList).
	NmdSubNames ::=     (list: NmdList, name: String, aux: NmdListOrNone). 
	DupNmdSubE  ::=     (list: NmdList, name: String, aux1: NmdListOrNone, aux2: NmdListOrNone).

	MaxNmdSubE(e) :- NmdSubE(e), no NmdSubE(NmdTupType(_, e)), no NmdSubE(NamedExprs(_, _, e)).
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NmdTupType(NmdTupTypeField(_, name, _), tl). 
	NmdSubNames(list, name, tl) :- MaxNmdSubE(list), list = NamedExprs(name, _, tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NmdTupType(NmdTupTypeField(_, name, _), tl). 
	NmdSubNames(list, name, tl) :- NmdSubNames(list, _, aux), aux = NamedExprs(name, _, tl). 

    [ rule_Classes = '"error, msg: same name appears more than once in name tuple or named tuple type"']
	DupNmdSubE(list, name, tl, tl') :- NmdSubNames(list, name, tl), NmdSubNames(list, name, tl'), tl != tl'.

    /*************************************************************/
    /*                          L-values                         */
    /*************************************************************/
	LValueError    ::= (cntxt: TypingContext, stmt: BinStmt + FunStmt).
	ModStmtSubExpr ::= sub (cntxt: TypingContext, stmt: BinStmt + FunStmt, expr: Expr).
	IsLValue       ::=     (cntxt: TypingContext, expr: Expr, writesGlobal: Boolean). 
	IsLValue(c, e, FALSE)  :- ModStmtSubExpr(c, _, e), e = Name(n), TypeOfLocalVar(c, n, _).		
    IsLValue(c, e, TRUE)   :- ModStmtSubExpr(c, _, e), e = Name(n), VarDecl(n, c.owner, t), no TypeOfLocalVar(c, n, _). 
    IsLValue(c, e, wg)     :- ModStmtSubExpr(c, _, e), e = Field(e', _), IsLValue(c, e', wg). 
    IsLValue(c, e, wg)     :- ModStmtSubExpr(c, _, e), e = BinApp(IDX, e', _), IsLValue(c, e', wg). 

    [ rule_Classes = '"error, msg: invalid LHS; must have the form LHS ::= var | LHS[expr] | LHS.name"']
	LValueError(c, e) :- SubSE(c, e), e = BinStmt(_, e', _, _), no IsLValue(c, e', _);
						 SubSE(c, e), e = FunStmt(_, _, _, x, _, _), x: Name, no IsLValue(c, x, _).

    /*************************************************************/
    /*                      Function Returns                     */
    /*************************************************************/

	FunRetError ::= (cntxt: FunDecl).

	[rule_Classes = '"error, msg: function must return a value"']
	FunRetError(f) :- f is FunDecl, rt = f.return, rt : TypeExpr, no { r | SubSE(c, r), r : Return }.

    /*************************************************************/
    /*                      Control Impurity                     */
    /*************************************************************/
    PurityError ::= (cntxt: TypingContext + StateDecl + TransDecl, expr: Typeable + String + AnonFunDecl).

	ControlImpure ::= (TypingContext).
	ControlImpure(c) :- SubSE(c, e), e : Raise.
	ControlImpure(c) :- SubSE(c, e), e = NulStmt(POP, _).
	ControlImpure(c) :- SubSE(c, e), e : Receive, ReceiveCases(c, e, cases), cases = Cases(_, act, _), ControlImpure(act).
	ControlImpure(c) :- SubSE(c, e), e = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), ControlImpure(called);
						SubSE(c, e), e = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), ControlImpure(called).
    ControlImpure(c) :- SubSE(c, e), e = FunStmt(n, NIL, _, _, _, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), ControlImpure(called);
						SubSE(c, e), e = FunStmt(n, m, _, _, _, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is StateDecl(_, owner, _, n, _), called.name = n, FunAvailable(called, owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is StateDecl(_, owner, _, called, _), called : AnonFunDecl, ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, n) :- 
	       c is TransDecl(src, _, _, n), called.name = n, FunAvailable(called, src.owner), ControlImpure(called).

    [ rule_Classes = '"error, msg: function may cause a change in current state; this is not allowed here"']
    PurityError(c, called) :- 
	       c is TransDecl(src, _, _, called), called : AnonFunDecl, ControlImpure(called).


    /*************************************************************/
    /*                      Monitor Checking                     */
    /*************************************************************/
	MonitorError ::= (cntxt: StateDecl + TransDecl + DoDecl, expr: String + AnonFunDecl).
	MonitorImpure ::= (TypingContext).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(NONDET).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(FAIRNONDET).
	MonitorImpure(c) :- SubSE(c, e), e = NulApp(THIS).
	MonitorImpure(c) :- SubSE(c, e), e : New.
	MonitorImpure(c) :- SubSE(c, e), e : Send.
	MonitorImpure(c) :- SubSE(c, e), e : NewStmt.
	MonitorImpure(c) :- SubSE(c, e), e : Announce.
	MonitorImpure(c) :- SubSE(c, e), e : Receive.
	MonitorImpure(c) :- SubSE(c, e), e = NulStmt(POP, _).
    MonitorImpure(c) :- SubSE(c, e), e = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), MonitorImpure(called);
						SubSE(c, e), e = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), MonitorImpure(called).
    MonitorImpure(c) :- SubSE(c, e), e = FunStmt(n, NIL, _, _, _, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), MonitorImpure(called);
						SubSE(c, e), e = FunStmt(n, m, _, _, _, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, n) :- 
	       c is StateDecl(_, owner, n, _, _), owner.kind = MONITOR, called.name = n, FunAvailable(called, owner), MonitorImpure(called);
		   c is StateDecl(_, owner, _, n, _), owner.kind = MONITOR, called.name = n, FunAvailable(called, owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, called) :- 
	       c is StateDecl(_, owner, called, _, _), owner.kind = MONITOR, called : AnonFunDecl, MonitorImpure(called);
		   c is StateDecl(_, owner, _, called, _), owner.kind = MONITOR, called : AnonFunDecl, MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, n) :- 
	       c is TransDecl(src, _, _, n), src.owner.kind = MONITOR, called.name = n, FunAvailable(called, src.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
    MonitorError(c, called) :- 
	       c is TransDecl(src, _, _, called), src.owner.kind = MONITOR, called : AnonFunDecl, MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
	MonitorError(c, n) :-	
		   c is DoDecl(src, _, n), src.owner.kind = MONITOR, called.name = n, FunAvailable(called, src.owner), MonitorImpure(called).

	[ rule_Classes = '"error, msg: monitor may not use this keyword or perform nondeterministic choice or create machines or execute send, monitor, receive and pop statements"']
	MonitorError(c, called) :- 
		   c is DoDecl(src, _, called), src.owner.kind = MONITOR, called : AnonFunDecl, MonitorImpure(called).

    /*************************************************************/
    /*                         Receive Labels                       */
    /*************************************************************/
    BadLabelError ::= (TypingContext).
	Continuation ::= Receive + FunStmt.

	//// Every receive statement must have a label that is unique within a context.
	//// This constraint simplifies P compilers.
	
	//// A term path describes how to reach a term.
	//// 0 means this term is reached by following the 1st child stmt of the parent term.
	//// 1 means this term is reached by following the 2nd child stmt of the parent term.
	TermPath    ::= (child: { 0, 1 }, prev: TermPath + { NIL }).
	ReachedContinuation ::= (cntxt: TypingContext, stmt: Stmt, path: TermPath + { NIL }).
	ReachedContinuation(c, c.body, NIL) :- SubCntxt(c).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = While(_, s', _),  p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Ite(_, s', _, _), p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Ite(_, _, s', _), p' = TermPath(1, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Seq(s', _),    p' = TermPath(0, p).
	ReachedContinuation(c, s', p')  :- ReachedContinuation(c, s, p), s = Seq(_, s'),    p' = TermPath(1, p).

    [ rule_Classes = '"error, msg: function contains bad labeling of Receive"']
	BadLabelError(c) :-
	    ReachedContinuation(c, s, p), ReachedContinuation(c, s', p'), s : Continuation, s' : Continuation, s.label = s'.label, p != p'.
	
    /*************************************************************/
    /*                            Impurity                       */
    /*************************************************************/
	Impure ::= (FunDecl).

	Impure(c) :- SubSE(c, e), c : FunDecl, e = NulApp(NONDET).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = NulApp(FAIRNONDET).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = BinStmt(_, e', e'', _), IsLValue(c, e', TRUE).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = NewStmt(_, _, _).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = New(_, _).
	Impure(c) :- SubSE(c, e), c : FunDecl, e = Send(_, _, _, _, _). 
	Impure(c) :- SubSE(c, e), c : FunDecl, e = Receive(_, _, _).
	Impure(c) :- c: FunDecl, ControlImpure(c).
	Impure(c) :- SubSE(c, e), e = FunApp(n, NIL, _), c : FunDecl, called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
				 SubSE(c, e), e = FunApp(n, m, _), c : FunDecl, called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called).
	Impure(c) :- SubSE(c, e), e = FunStmt(n, NIL, _, _, _, _), c : FunDecl, called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
				 SubSE(c, e), e = FunStmt(n, m, _, _, _, _), c : FunDecl, called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called).
	Impure(c) :- SubSE(c, e), e = FunStmt(n, _, _, aout, _, _), c : FunDecl, aout : Name, IsLValue(c, aout, TRUE).

    [ rule_Classes = '"error, msg: this function must be pure. Impure functions can only be called like "foo(...);" or "x = foo(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),           e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = UnApp(_, e'),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, e', _),     e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, _, e'),     e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Field(e', _),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Cast(e', _),          e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Exprs(_, e', _),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);              
       SubSE(c, e), e = NamedExprs(_, e', _), e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = NewStmt(_, e', _),       e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(e', _, _),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(_, e', _),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);        
       SubSE(c, e), e = Send(e', _, _, _, _),       e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, e', _, _, _),       e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, _, e', _, _),       e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Announce(e', _, _),       e' = FunApp(n, NIL,_), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Announce(_, e', _),       e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Assert(e', _, _),        e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Return (e', _),          e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = While(e', _, _),         e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Ite(e', _, _, _),        e' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', e'', _),  e'' = FunApp(n, NIL, _), called.name = n, called.owner = c.owner, FunAvailable(called, c.owner), Impure(called), toSymbol(e') != #Name;
	   
	   SubSE(c, e), e = New(_, e'),           e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = UnApp(_, e'),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, e', _),     e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinApp(_, _, e'),     e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Field(e', _),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Cast(e', _),          e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Exprs(_, e', _),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);              
       SubSE(c, e), e = NamedExprs(_, e', _), e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = NewStmt(_, e', _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(e', _, _),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Raise(_, e', _),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);        
       SubSE(c, e), e = Send(e', _, _, _, _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, e', _, _, _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Send(_, _, e', _, _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Announce(e', _, _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Announce(_, e', _),       e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);    
       SubSE(c, e), e = Assert(e', _, _),        e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Return (e', _),          e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = While(e', _, _),         e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = Ite(e', _, _, _),        e' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called);
       SubSE(c, e), e = BinStmt(_, e', e'', _),  e'' = FunApp(n, m, _), called.name = n, called.owner = ModuleDecl(m), FunAvailable(called, c.owner), Impure(called), toSymbol(e') != #Name.

    [ rule_Classes = '"error, msg: new M(...) can only be called like "new M(...);" or "x = new M(...);" "']
    PurityError(c, e') :- 
       SubSE(c, e), e = New(_, e'),           e' : New;
       SubSE(c, e), e = UnApp(_, e'),         e' : New;
       SubSE(c, e), e = BinApp(_, e', _),     e' : New;
       SubSE(c, e), e = BinApp(_, _, e'),     e' : New;    
       SubSE(c, e), e = Field(e', _),         e' : New;
       SubSE(c, e), e = Cast(e', _),          e' : New;    
       SubSE(c, e), e = Exprs(_, e', _),         e' : New;              
       SubSE(c, e), e = NamedExprs(_, e', _), e' : New;
       SubSE(c, e), e = NewStmt(_, e', _),       e' : New;
       SubSE(c, e), e = Raise(e', _, _),         e' : New;
       SubSE(c, e), e = Raise(_, e', _),         e' : New;        
       SubSE(c, e), e = Send(e', _, _, _, _),       e' : New;
       SubSE(c, e), e = Send(_, e', _, _, _),       e' : New;
       SubSE(c, e), e = Send(_, _, e', _, _),       e' : New;    
       SubSE(c, e), e = Announce(e', _, _),       e' : New;
       SubSE(c, e), e = Announce(_, e', _),       e' : New;    
       SubSE(c, e), e = Assert(e', _, _),        e' : New;
       SubSE(c, e), e = Return (e', _),          e' : New;
       SubSE(c, e), e = While(e', _, _),         e' : New;
       SubSE(c, e), e = Ite(e', _, _, _),        e' : New;
       SubSE(c, e), e = BinStmt(_, e', e'', _),  e'' : New, toSymbol(e') != #Name.
						 	                                          
    /*************************************************************/
    /*                      Type Comparability                   */
    /*************************************************************/
    //// These are the pairs of types whose relationships must be computed.
    CompTypeRel ::= (TypeExpr + { NIL, ERROR }, TypeExpr + { NIL, ERROR }).
    CompTypeRel(ta', tb')                    :- CompTypeRel(ta, tb), ta = SeqType(ta'), tb = SeqType(tb').
    CompTypeRel(da, db), CompTypeRel(ca, cb) :- CompTypeRel(ta, tb), ta = MapType(da, ca), tb = MapType(db, cb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = TupType(la, ra), tb = TupType(lb, rb).
    CompTypeRel(la, lb), CompTypeRel(ra, rb) :- CompTypeRel(ta, tb), ta = NmdTupType(lfa, ra), tb = NmdTupType(lfb, rb), la = lfa.type, lb = lfb.type.
    
	CompTypeRel(t1, t2')      :- TypeOfArg1(c, e, t1), e = Cast(_, t2), TypeExpansion(t2, t2').
	CompTypeRel(t1, t2)       :- TypeOfArg2(c, e, t1, t2), e = BinApp(op, _, _), op : PolyRel.
	CompTypeRel(t2, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinApp(IDX, _, _), t1 = MapType(dom, cod).
	CompTypeRel(t1, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinApp(IN, _, _), t2 = MapType(dom, _).      
	CompTypeRel(t1, inpt)     :- TypeOfArg1(c, e, t1), e = FunApp(n, NIL, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, _);
								  TypeOfArg1(c, e, t1), e = FunApp(n, m, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, _).
	CompTypeRel(t1, t)        :- TypeOfArg1(c, e, t1), e : Return, FuncSig(c, _, t).
	CompTypeRel(null, plt)    :- CommStmtPLType(c, e, plt), e = Raise(_, NIL, _), null = BaseType(NULL).
	CompTypeRel(pt, plt)      :- CommStmtPLType(c, e, plt), e = Raise(_, p, _), p != NIL, TypeOf(c, p, pt).
	CompTypeRel(null, plt)    :- SubSE(c, e), e = Send(_, _, NIL, _, _), null = BaseType(NULL), CommStmtPLType(c, e, plt).
	CompTypeRel(t3, plt)      :- TypeOfArg3(c, e, t1, t2, t3), e : Send, CommStmtPLType(c, e, plt).
	CompTypeRel(null, plt)    :- SubSE(c, e), e = Announce(_, NIL, _), null = BaseType(NULL), CommStmtPLType(c, e, plt).
	CompTypeRel(t2, plt)      :- TypeOfArg2(c, e, t1, t2), e : Announce, CommStmtPLType(c, e, plt).
	CompTypeRel(t2, plt)      :- TypeOfArg2(c, e, t1, t2), e = Announce(_, _, _), CommStmtPLType(c, e, plt).
	CompTypeRel(t2, t1)       :- TypeOfArg2(c, e, t1, t2), e = BinStmt(ASSIGN, _, _, _).	
	CompTypeRel(t2, dom)      :- TypeOfArg2(c, e, t1, t2), e = BinStmt(REMOVE, _, _, _), t1 = MapType(dom, cod).	
	CompTypeRel(key, dom)     :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).
	CompTypeRel(value, cod)   :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = MapType(dom, cod), t2 = TupType(key, TupType(value, NIL)).
	CompTypeRel(value, inner) :- TypeOfArg2(c, e, t1, t2), e = BinStmt(INSERT, _, _, _), t1 = SeqType(inner), t2 = TupType(idx, TupType(value, NIL)).
	CompTypeRel(t1, inpt)     :- TypeOfArg1(c, e, t1), e = FunStmt(n, NIL, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, inpt, _);
								 TypeOfArg1(c, e, t1), e = FunStmt(n, m, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, inpt, _).
	CompTypeRel(t1, t2)       :- TypeOfArg2(c, e, _, t2), e = FunStmt(n, NIL, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = c.owner, FuncSig(decl, _, t1);
								 TypeOfArg2(c, e, _, t2), e = FunStmt(n, m, _, _, _, _), FunAvailable(decl, c.owner), decl.name = n, decl.owner = ModuleDecl(m), FuncSig(decl, _, t1).

	//// TypeRel determines the relationship type expressions ta and tb.
    //// If types are not subtype related, then they can
    //// either have an empty (EMPTY) or nonempty (NONEMPTY) intersection. 
    TypeRel ::= (ta: TypeExpr + { ERROR, NIL }, tb: TypeExpr + { ERROR, NIL }, rel: { SUB, SUP, EMPTY, NONEMPTY }).
                            
    //// (1) Type (non-) emptiness.       
    // For convenience, the ERROR type is incomparable to all types, even itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = ERROR.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = ERROR.
    
    // For convenience, the NIL type is incomparable to all types, except itself.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NIL, t != NIL.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s = NIL, t != NIL.
    
    // The NULL type has empty intersections with NonNullBase and complex types.
    NonNullBase ::= (TypeExpr).
	NonNullBase(type) :- type = BaseType(BOOL).
	NonNullBase(type) :- type = BaseType(INT).
	NonNullBase(type) :- TypeDef(name, NIL), type = NameType(name).
    ComplexType ::= TupType  + NmdTupType + SeqType + MapType.
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), NonNullBase(s), t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), NonNullBase(s), t = BaseType(NULL).
    
    TypeRel(s, t, EMPTY)   :- CompTypeRel(s, t), s : ComplexType, t = BaseType(NULL).
    TypeRel(t, s, EMPTY)   :- CompTypeRel(t, s), s : ComplexType, t = BaseType(NULL).
        
    // NonNullBase types have empty intersections with all types, except themselves and ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), NonNullBase(s), s != t, t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), NonNullBase(s), s != t, t != BaseType(ANY).

    // NullBase types have empty intersections with all types, except themselves, ANY, and NULL.
    NullBase    ::= (TypeExpr).
	NullBase(type) :- type = BaseType(EVENT).
	NullBase(type) :- type = BaseType(REAL). 
	   
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), NullBase(s), NonNullBase(t).
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), NullBase(s), NonNullBase(t).
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), NullBase(s), toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
    TypeRel(t, s, EMPTY)    :- CompTypeRel(t, s), NullBase(s), toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
          
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), NullBase(s), NullBase(t), s != t.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), NullBase(s), NullBase(t), s != t.

	//Interface Type has empty intersection with all the types except themselves, ANY, REAL and NULL
	TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : InterfaceType, t = BaseType(kt), kt != ANY, kt != NULL, kt != REAL.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : InterfaceType, t = BaseType(kt), kt != ANY, kt != NULL, kt != REAL.
	TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : InterfaceType, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : InterfaceType, toSymbol(t) != #BaseType, toSymbol(t) != #InterfaceType.

    // Complex types have empty intersections with all differing type kinds, except ANY.
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    TypeRel(t, s, EMPTY) :- CompTypeRel(t, s), s : ComplexType, toSymbol(s) != toSymbol(t), t != BaseType(ANY).
    
    // Sequences are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', NONEMPTY). 
    
    // Maps are EMPTY or NONEMPTY if their inner types are. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(sd, _),  t = MapType(td, _),  TypeRel(sd, td, EMPTY).
    
    TypeRel(s, t, EMPTY)    :- CompTypeRel(s, t), s = MapType(_, sc),  t = MapType(_, tc),  TypeRel(sc, tc, EMPTY).    
    
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, NONEMPTY), TypeRel(sc, tc, NONEMPTY). 

    // Tuples and NmdTups are EMPTY if their lengths differ. (Only need one version of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : TupType, t : TupType, lstLength(#TupType, s) != lstLength(#TupType, t).
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s : NmdTupType, t : NmdTupType, lstLength(#NmdTupType, s) != lstLength(#NmdTupType, t).
    
    // Tuples are EMPTY if any pair of inner types is EMPTY.  (Only need one version of some of these rules.)
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(s', _), t = TupType(t', _), TypeRel(s', t', EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = TupType(_, s'), t = TupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                                                           
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = TupType(s', s''), t = TupType(t', t''), 
                               TypeRel(s', t', SUB), TypeRel(s'', t'', SUP), s' != t', s'' != t''.
                               
    // Named Tuples are EMPTY if any pair of inner types is EMPTY or they name arguments differently. (Only need one version of some of these rules.) 
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), fs.name != ft.name. 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, _), t = NmdTupType(ft, _), TypeRel(fs.type, ft.type, EMPTY). 
    
    TypeRel(s, t, EMPTY) :- CompTypeRel(s, t), s = NmdTupType(_, s'), t = NmdTupType(_, t'), TypeRel(s', t', EMPTY). 
    
    // Named Tuples are NONEMPTY if not all inners types are in identical super / sub relationships. 
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, NONEMPTY), TypeRel(s'', t'', r), r != EMPTY.
                                                            
    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, r), TypeRel(s'', t'', NONEMPTY), r != EMPTY.

    TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
    TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, 
                               TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUP), fs.type != ft.type, s'' != t''.
                               
    //// (3) Sub-typing.                
    // Any non-ERROR type is sub-type related to itself.
    TypeRel(s, s, SUB) :- CompTypeRel(s, s), s != ERROR.
    TypeRel(s, s, SUP) :- CompTypeRel(s, s), s != ERROR.
   
    // Every proper type is a sub-type of any.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s != ERROR, s != NIL, t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s != ERROR, s != NIL, t = BaseType(ANY).
        
    // NULL is a subtype of all Nullable types.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = BaseType(NULL), t = BaseType(ANY).
    TypeRel(t, s, SUP) :- CompTypeRel(t, s), s = BaseType(NULL), t = BaseType(ANY).
    
    TypeRel(s, t, SUB) :-  CompTypeRel(s, t), s = BaseType(NULL), NullBase(t).
    TypeRel(t, s, SUP) :-  CompTypeRel(t, s), s = BaseType(NULL), NullBase(t).
    
	// Interface type is a subtype of the machine base-type
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), t = BaseType(REAL), s : InterfaceType.
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), t = BaseType(REAL), s : InterfaceType.

	TypeRel(s, t, NONEMPTY) :- CompTypeRel(s, t), s : InterfaceType, t : InterfaceType, s != t.
	TypeRel(t, s, NONEMPTY) :- CompTypeRel(t, s), s : InterfaceType, t : InterfaceType, s != t.

	//Interface type is a supertype of NULL
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), t : InterfaceType, s = BaseType(NULL).
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), t : InterfaceType, s = BaseType(NULL).

	//Interface type is a subtype of ANY
	TypeRel(s, t, SUB) :- CompTypeRel(s, t), s : InterfaceType, t = BaseType(ANY).
	TypeRel(t, s, SUP) :- CompTypeRel(t, s), s : InterfaceType, t = BaseType(ANY).


    // Sequences are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUB). 
    TypeRel(s, t, SUP)    :- CompTypeRel(s, t), s = SeqType(s'), t = SeqType(t'), TypeRel(s', t', SUP). 
    
    // Maps are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUB), TypeRel(sc, tc, SUB). 
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = MapType(sd, sc), t = MapType(td, tc), TypeRel(sd, td, SUP), TypeRel(sc, tc, SUP). 
    
    // Tuples are subtype related if their inner types are subtype related.
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUB), TypeRel(s'', t'', SUB).
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = TupType(s', s''), t = TupType(t', t''), TypeRel(s', t', SUP), TypeRel(s'', t'', SUP).
    
    TypeRel(s, t, SUB) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUB), TypeRel(s'', t'', SUB).    
    TypeRel(s, t, SUP) :- CompTypeRel(s, t), s = NmdTupType(fs, s''), t = NmdTupType(ft, t''), fs.name = ft.name, TypeRel(fs.type, ft.type, SUP), TypeRel(s'', t'', SUP).   
	
    /*************************************************************/
    /*                      Payload Checking                    */
    /*************************************************************/	
    ConstructorType ::= (m: MachineDecl, s: StateDecl, t: TypeExpr).
	ConstructorType(m, s, ft) :- s is StateDecl, m = s.owner, s.name = m.start, PayloadVarType(s, ft).

	EventPayloadType ::= (e: String + { NULL, HALT }, t: TypeExpr).
	EventPayloadType(e, et) :- EventDecl(e, _, t), t: TypeExpr, TypeExpansion(t, et).
	EventPayloadType(e, t)  :- EventDecl(e, _, NIL), t = BaseType(NULL).
	EventPayloadType(NULL, t) :- t = BaseType(NULL).
	EventPayloadType(HALT, t) :- t = BaseType(ANY).

	PayloadVarTypeAux ::= (StateDecl + TransDecl + DoDecl + Cases, TypeExpr).
	PayloadVarType ::= (StateDecl + TransDecl + DoDecl + Cases, TypeExpr).
	PayloadVarTypeAux(s, type) :- s is StateDecl, r = lstReverse(#NmdTupType, s.entryAction.envVars), type = r.hd.type.
	PayloadVarTypeAux(t, type) :- t is TransDecl, r = lstReverse(#NmdTupType, t.action.envVars), type = r.hd.type.
	PayloadVarTypeAux(d, type) :- d is DoDecl, r = lstReverse(#NmdTupType, d.action.envVars), type = r.hd.type.
	PayloadVarTypeAux(cases, type) :- SubSE(_, cases), cases: Cases, r = lstReverse(#NmdTupType, cases.action.envVars), type = r.hd.type.
	PayloadVarType(x, ft) :- PayloadVarTypeAux(x, type), TypeExpansion(type, ft).
	
	CompTypeRel(et, ft) :- EventPayloadType(_, et), PayloadVarType(_, ft);
						   SubSE(c, n), n: New, TypeOf(c, n.arg, et), et: TypeExpr, PayloadVarType(_, ft);
						   SubSE(c, n), n: NewStmt, TypeOf(c, n.arg, et), et: TypeExpr, PayloadVarType(_, ft).

    PayloadError ::= (TransDecl + DoDecl + StateDecl + Cases + New + NewStmt).
	
	////Rules for checking the constructor parameters with event handlers
	[ rule_Classes = '"error, msg: Payload type for event must be subtype of payload type of transition function;"']
	PayloadError(t) :- t is TransDecl, EventPayloadType(t.trig, et), PayloadVarType(t, ft),
	                   TypeRel(et, ft, k), et != ft, k != SUB, ft != BaseType(NULL).
	[ rule_Classes = '"error, msg: Payload type for event must be subtype of payload type of do function;"']
	PayloadError(d) :- d is DoDecl, EventPayloadType(d.trig, et), PayloadVarType(d, ft),
	                   TypeRel(et, ft, k), et != ft, k != SUB, ft != BaseType(NULL).
	[ rule_Classes = '"error, msg: Payload type for event on incoming transition must be subtype of payload type of state entry function;"']
	PayloadError(s) :- t is TransDecl, EventPayloadType(t.trig, et), 
					   s is StateDecl, s.name = t.dst, s.owner = t.src.owner, PayloadVarType(s, ft),
					   TypeRel(et, ft, k), et != ft, k != SUB, ft != BaseType(NULL).
	[ rule_Classes = '"error, msg: Payload type for event must be subtype of payload type of case function;"']
	PayloadError(cases) :- SubSE(_, cases), cases: Cases, EventPayloadType(cases.trig, et), PayloadVarType(cases, ft),
						   TypeRel(et, ft, k), et != ft, k != SUB, ft != BaseType(NULL). 

	//// Rules for checking the constructor parameters during new
	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of entry function of start state;"']
	PayloadError(n) :- SubSE(c, n), n = New(name, NIL), ConstructorType(m, _, ft), m.name = name, no MachineReceivesDecl(m, _), ft != BaseType(NULL).

	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of the created interface;"']
	PayloadError(n) :- SubSE(c, n), n = New(name, NIL), InterfaceTypeDecl(name, _, ft), ft != BaseType(NULL).
	
	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of entry function of start state;"']
	PayloadError(n) :- SubSE(c, n), n = New(name, _), ConstructorType(m, _, ft), m.name = name, no MachineReceivesDecl(m, _), TypeOfArg1(c, n, type), type: TypeExpr, 
					   TypeRel(type, ft, k), type != ft, k != SUB.

	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of the created interface;"']
	PayloadError(n) :- SubSE(c, n), n = New(name, _), InterfaceTypeDecl(name, _, ft), TypeOfArg1(c, n, type), type: TypeExpr, 
					   TypeRel(type, ft, k), type != ft, k != SUB.

	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of entry function of start state;"']
	PayloadError(n) :- SubSE(c, n), n = NewStmt(name, NIL, _), ConstructorType(m, _, ft), m.name = name, no MachineReceivesDecl(m, _), ft != BaseType(NULL).	
	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of the created interface;"']
	PayloadError(n) :- SubSE(c, n), n = NewStmt(name, NIL, _), InterfaceTypeDecl(name, _, ft), ft != BaseType(NULL).

	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of entry function of start state;"']
	PayloadError(n) :- SubSE(c, n), n = NewStmt(name, _, _), ConstructorType(m, _, ft), m.name = name, no MachineReceivesDecl(m, _), TypeOfArg1(c, n, type), type: TypeExpr,
					   TypeRel(type, ft, k), type != ft, k != SUB.
	[ rule_Classes = '"error, msg: Payload type of constructor must be subtype of payload type of the created interface;"']
	PayloadError(n) :- SubSE(c, n), n = NewStmt(name, _, _), InterfaceTypeDecl(name, _, ft), TypeOfArg1(c, n, type), type: TypeExpr,
					   TypeRel(type, ft, k), type != ft, k != SUB.

	[ rule_Classes = '"error, msg: Null type must be subtype of payload type of entry function of start state;"']
	PayloadError(s) :- ConstructorType(m, s, ft), m.isMain = TRUE, type = BaseType(NULL), TypeRel(type, ft, k), type != ft, k != SUB.
	[ rule_Classes = '"error, msg: Null type must be subtype of payload type of entry function of start state;"']
	PayloadError(s) :- ConstructorType(m, s, ft), m.kind = MONITOR, type = BaseType(NULL), TypeRel(type, ft, k), type != ft, k != SUB.
}